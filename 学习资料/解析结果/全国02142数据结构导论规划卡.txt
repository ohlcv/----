=== 第 1 页 ===
02142《数据结构导论》
规划卡
考试题型及分值分布
类别 题型 题量 分值/题 总分
选择题 单项选择题 15题 2分 30分
非选择题填空题 13题 2分 26分
应用题 5题 6分 30分
算法设计题 2题 7分 14分
注：本资料题型根据考试大纲或历年真题进行预测，仅供复习参考

=== 第 2 页 ===
前言
高等教育自学考试是个人自学和国家考试相结合的高等教育形式，是我国社会主义高等教育体系的重
要组成部分。自学考试既能够为国家培养更多的人才，也是广大有志青年提升科学文化素质、提升自身竞
争力的重要途径。
为了提高自学考试考生的学习效果，也为了给相关的社会助学机构和教师提供更有针对性、更高效的
教学辅导资料，同时对我们几年来自学考试工作的经验进行总结，我们集中优质的师资力量，钻研科学的
教学理论和系统高效的学习方法，编写了《数据结构导论学习规划卡》。
编写本书的基本原则是：
第一，以纲为本。即根据最新的《数据结构导论》自学考试大纲内容和考核知识的能力层次要求编写，
将教材与考纲紧密结合，突出自学考试的特点，特别注意基本概念和基本原理的全面性和准确性，着重理
论联系实际，使自学者系统掌握课程的基本内容。
第二，重点突出。在研究该学科历年真题的基础上，按照知识点的考试频率、考试题型特点，以自学
考试官方教材为依托，精准提炼考试热点，让考生在学习的时候做到有的放矢，深入把握学习的重难点，
提高考试成绩。
第三，思维导图。在每一章、每一节的内容开始，以导图的形式呈现出本章内容、本小节内容的整体
知识体系，清晰化展示本章内容的知识架构，帮助考生理解知识点之间的逻辑关系。
第四，真题再现。针对每个章节内容，同步配套加入科目真题及习题，自考考生在系统学习知识内容
后，通过匹配的习题强化练习，实时检测学习效果，及时查漏补缺，同时强化记忆效果，做到对知识的理
解掌握。
在本书编写的过程中，我们得到了设计部、品牌部、总裁办、学院运营中心等部门的大力协助，尤其
是潘国强校长、邓小兴校长的悉心指导，为我们的编写指明了方向，在此，我们表示由衷的感谢，并不忘
初心，继续恳切努力！因为时间及水平有限，本书难免存在不足之处，敬请广大读者批评指正!
举例说明：
【识记】、【领会】、【应用】代表的是考试大纲对相应知识点的考核要求。★代表的是该类知识点
在考试中的题量分布情况，★级数越多，考试频率越高。
（1）识记类的知识点要求考生能知道有关名词、概念、事实的含义，并能准确地认识和表述；
（2）领会类的知识点要求考生在识记的基础上，把握概念、观点、方法及其之间的关系，更强调对知
识点的理解；
（3）应用类的知识点要求考生能够调动教材中的某个或多个知识点分析问题并提出解决方法。

=== 第 3 页 ===
I目录
第一章概论..................................................................................................................................................................1
第一节引言..........................................................................................................................................................2
第二节基本概念和术语......................................................................................................................................5
第三节算法及描述..............................................................................................................................................9
第四节算法分析................................................................................................................................................10
第二章线性表............................................................................................................................................................16
第一节线性表的基本概念................................................................................................................................18
第二节线性表的顺序存储................................................................................................................................19
第三节线性表的链接存储................................................................................................................................25
第四节其他运算在单链表上的实现................................................................................................................32
第五节其他链表................................................................................................................................................36
第六节顺序实现与链接实现的比较................................................................................................................40
第三章栈、队列和数组............................................................................................................................................41
第一节栈............................................................................................................................................................43
第二节队列........................................................................................................................................................55
第三节数组........................................................................................................................................................67
第四节应用举例................................................................................................................................................73
第四章树和二叉树....................................................................................................................................................78
第一节树的基本概念........................................................................................................................................80
第二节二叉树....................................................................................................................................................83
第三节二叉树的存储结构................................................................................................................................87
第四节二叉树的遍历........................................................................................................................................91
第五节树和森林..............................................................................................................................................101
第六节判定树和哈夫曼树..............................................................................................................................109
第五章图..................................................................................................................................................................116
第一节图的基本概念......................................................................................................................................117
第二节图的存储结构......................................................................................................................................122
第三节图的遍历..............................................................................................................................................128
第四节图的应用..............................................................................................................................................135
第六章查找..............................................................................................................................................................148
第一节基本概念..............................................................................................................................................150

=== 第 4 页 ===
II第二节静态查找表..........................................................................................................................................152
第三节二叉排序树..........................................................................................................................................158
第四节散列表..................................................................................................................................................164
第七章排序..............................................................................................................................................................171
第一节概述......................................................................................................................................................173
第二节插入排序..............................................................................................................................................175
第三节交换排序..............................................................................................................................................177
第四节选择排序..............................................................................................................................................183
第五节归并排序..............................................................................................................................................192

=== 第 5 页 ===
第一章概论
第1页第一章概论
►知识体系
►考点透析
知识点 考核要求 考试题型 重点星级
计算机解决问题的步骤 领会 填空
数据结构的作用例子 领会 填空
数据、数据元素和数据项 识记 单选、填空 ★
数据的逻辑结构 识记 单选
数据的存储结构 识记 填空 ★
运算 识记
算法及描述 简单应用
时间复杂度 简单应用 单选、算法设计 ★★★
空间复杂度 简单应用 填空、算法设计 ★★

=== 第 6 页 ===
《数据结构导论》学习规划卡
第2页第一节引言
►知识体系
简单地说，数据结构（DataStructure）是计算机组织数据和存储数据的方式。更进一步地说，数据结构
是指一组相互之间存在一种或多种特定关系的数据的组织方式和它们在计算机内的存储方式，以及定义在
该组数据上的一组操作。合理的数据结构可降低程序设计的复杂性，提高程序执行的效率。
知识点1计算机解决问题的步骤【填空】
计算机解决一个具体问题时，一般需要经过以下几个步骤：
（1）从具体的问题抽象出一个适当的数学模型；
（2）设计一个求解该数学模型的算法；
（3）用某种计算机语言编写实现该算法的程序，调试和运行程序直至最终得到问题的解答。
在每个步骤中，数据的表现形式都不相同，实际问题中的数据称为原始数据。在数学模型中，需要把
原始数据按照某种方式组织起来，以便很好地体现数据之间的关系，数据及数据的组织方式称为数据的逻
辑结构。为了能用计算机加工处理，逻辑结构还必须转换为能被计算机存储的存储结构。计算机解决问题
的步骤如图1-1所示。
知识点2数据结构的作用例子【填空】
1976年瑞士计算机科学家尼克劳斯•维尔特（NiklausWirth）曾提出一个著名公式：算法+数据结构=程
序。该公式简洁地描述了算法、数据结构和程序之间关系。下面通过两个例子来说明数据结构的作用。
【例1-1】学生档案管理问题。
一般来说，学生档案管理系统的功能包括：①查找，在学生档案中找出某人的档案；②读取，阅读通
过查找找到的某人档案；③插入，将学生的档案加到系统中；④删除，从学生档案中删除某个学生的档案；

=== 第 7 页 ===
第一章概论
第3页⑤更新，修改学生档案等有关内容。现在用计算机解决上述档案管理问题，即实现档案的自动（计算机）
管理。
【分析】为了能方便地查找某个学生信息，通常，档案管理人员会将这些学生档案组织成表格形式。
假定每个学生的档案信息只包括以下五个项目：学号、姓名、性别、年龄和入学成绩，见表1-1，该表格即
为学生档案数据的逻辑结构。为了在计算机中实现档案管理功能，还需要将该表格（逻辑结构）转换为存
储结构，存储到计算机中，再编写出实现全部处理所要求的程序。
【例1-2】地图着色问题。
在一个平面或球面上的任何地图能够只用四种颜色来着色，使相邻国家在地图上着有不同的颜色，这
就是著名的四色猜想问题。1976年四色猜想由爱普尔（K.I.Apple）、黑肯（W.Haken）和考西（J.Koch）利
用计算机证明了四种颜色足以对任何地图着色。
【分析】图1-2为描述了六个区域A、B、C、D、E、F的地图，采用四种颜色给该地图着色，使相邻
区域着上不同的颜色，图1-2为该问题的原始数据形式。
首先建立数学模型，在计算机解决该问题时，不需将该地图的“图像”存储在计算机中，而是将区域
之间的相邻关系存储到计算机中。将地图用平面图表示，地图上的每一个区域对应平面图中的一个顶点，
如两个区域在地图上相邻，它们在平面图中相应的两个顶点之间有一条边相连。图1-3为与图1-2地图对应
的平面图，是该问题的逻辑结构。通常这类地图、交通图等数学模型称为图。

=== 第 8 页 ===
《数据结构导论》学习规划卡
第4页
接下来要将建立起来的逻辑结构转换为能存储到计算机的存储结构，上述平面图含有两类信息，顶点
信息和边信息，顶点信息用一个一维数组v[n]来存储，n表示图中顶点的数目（在此问题中n=6，v[6]={A，
B，C，D，E，F}）。区域的相邻关系用矩阵adj6×6表示，若矩阵的第i行第j列元素为1，表示顶点i和j
之间有一条边，即区域i和j相邻，若矩阵的第i行第j列元素为0，表示顶点i和j之间没有边，即区域i
和j不相邻。根据图1-3地图的平面图可得矩阵adj6×6的表示，如图1-4所示。
图的存储结构并不唯一，上述图的存储结构称为邻接矩阵，在第五章还将介绍图的另一种存储结构邻
接表。
地图着色算法简单描述如下：
（1）给第一个顶点着色，用颜色1。
（2）试探对下一个顶点着色，这时枚举可用的四种颜色，通过和该顶点相邻的并且已经着色的顶点，
来判断这个颜色是否合法。如果找到某种颜色能够给该顶点着色，则用该颜色着色。
如果找不到，则回溯到上一顶点，修改该顶点的颜色，再试探对下一个顶点着色。这样通过不断地试
探和回溯，直至所有的顶点都能着上合法的颜色为止。
通过建立实际问题的数学模型，将实际问题转换为数学问题，对区域的着色转换为对图的顶点的着色，
再用矩阵作为存储结构，并设计一个算法解决问题，最后用某种计算机语言编写出地图着色的程序。
如果四种颜色分别选用红、黄、绿、蓝，图1-5给出了图1-2地图着色问题的一个可行解。

=== 第 9 页 ===
第一章概论
第5页
【考点练习】
【真题·填空】数据及数据的组织方式称为数据的______。
【答案】逻辑结构
【真题·填空】1976年瑞士计算机科学家NiklausWirth曾提出一个著名公式：算法+数据结构=______。
【答案】程序
第二节基本概念和术语
►知识体系


=== 第 10 页 ===
《数据结构导论》学习规划卡
第6页知识点1数据、数据元素和数据项【单选、填空】★
（1）数据
数据是所有被计算机存储、处理的对象。随着计算机科学和技术的发展，计算机加工处理的对象已从
早期的数值、布尔值等扩展到字符串、表格、图像甚至声音等。例如，利用迭代法求方程根的程序处理对
象为实数，语音采集程序处理的对象为声音。因此，数据的含义非常广泛。
（2）数据元素
数据元素是数据的基本单位，在程序中作为一个整体而加以考虑和处理。数据元素是运算的基本单位，
通常具有完整确定的实际意义。数据元素常常又简称为元素。
一般情况下，数据元素由数据项组成。在数据库中数据项又称为字段或域。它是数据的不可分割的最
小标识单位。
例如，在例1-1中，表1-1给出一组学生的档案记录，每一个记录是一个数据元素。每个记录包含学号、
姓名、性别、年龄和入学成绩等五个数据项，第一条记录的各个项分别是“1001”、“王韬”、“男”、
“20”和“589”，它们构成学生王韬的档案记录。数据元素也可以是只由一个数据项组成，这个数据项就
是该数据元素自身。
从宏观上看，数据、数据元素和数据项实际上反映了数据组织的三个层次，数据可由若干个数据元素
组成，而数据元素又可由若干个数据项组成。
数据结构是相互之间存在一种或多种特定关系的数据元素的集合。它包括数据的逻辑结构、数据的存
储结构和数据的基本运算。
知识点2数据的逻辑结构【单选】
数据的逻辑结构是指数据元素之间的逻辑关系。所谓逻辑关系是指数据元素之间的关联方式或“邻接
关系”。例如，在表1-1所示的表格中，第一条记录与第二条记录是邻接的，但是第一条记录与第三条记录
不相邻接，数据元素之间逻辑关系的整体称为逻辑结构。表1-1中数据的逻辑结构如图1-6b所示。图1-6
中的小圆圈称为结点。一个结点代表一个数据元素。结点之间的连线代表逻辑关系，即相应数据元素之间
的邻接关系。图1-6b中的逻辑结构反映了例1-1表格中数据元素的组织形式，即数据元素（记录）“一个
接一个地线性排列”，这种组织形式称为线性结构。

=== 第 11 页 ===
第一章概论
第7页
事实上，不同结构中的数据元素之间可以有不同的关系。根据数据元素之间的关系，通常有图1-6所示
的四类基本结构，它们反映了四类基本的数据组织形式。集合中任意两个结点之间都没有邻接关系，组织
形式松散。线性结构中结点按逻辑关系依次排列形成一条“链”，结点之间一个一个依次相邻接。树形结
构具有分支、层次特性，其形态像自然界中的树，上层的结点可以和下层多个结点相邻接，但下层结点只
能和上层的一个结点相邻接。图结构最复杂，其中任何两个结点都可以相邻接。
【例1-3】假设有一个公司，其中有1名经理，1～5名部门负责人，每个部门有1～10名员工，他们之
间的关系是，经理领导部门负责人，部门负责人领导员工。该数据的逻辑结构可形式化描述如下：
Company=（D，R）
其中D={B，M1，…，Mn，El1，…，Enm}，1≤n≤5，1≤m≤10；
R={BM，ME}；
BM={<B，Mi>|l≤i≤n，l≤n≤5}；
ME={<Mi，Eij>|1≤i≤n，l≤j≤m，1≤n≤5，1≤m≤10}。
数据的逻辑结构只是一种数学模型，体现了数据的组织方式，要在计算机中实现逻辑结构，还依赖它
在计算机中的存储结构。
知识点3数据的存储结构【填空】★
数据的逻辑结构在计算机中的实现称为数据的存储结构（或物理结构）。一般情况下，一个存储结构
包括以下两个部分：
（1）存储数据元素；
（2）数据元素之间的关联方式。
表示数据元素之间的关联方式主要有顺序存储方式和链式存储方式。

=== 第 12 页 ===
《数据结构导论》学习规划卡
第8页顺序存储方式是指所有存储结点存放在一个连续的存储区里。利用结点在存储器中的相对位置来表示
数据元素之间的逻辑关系。
链式存储方式是指每个存储结点除了含有一个数据元素外，还包含指针，每个指针指向一个与本结点
有逻辑关系的结点，用指针表示数据元素之间的逻辑关系。
除了上述两种存储方式之外，还有索引存储方式和散列存储方式。
一种逻辑结构可以采用一种或几种存储方式来表达数据元素之间的逻辑关系，相应的存储结构称为给
定逻辑结构的存储实现或存储映像。如何来描述存储结构呢？可以分别在机器级和语言级上讨论。机器级，
即讨论存储结构在计算机存储器里的表示形式，直接以内存地址来描述存储结构。语言级，即用程序设计
语言中的类型说明、变量说明等手段来描述存储结构，一般语言中有几种常用的数据类型，如数组、结构
体和指针等，用这些类型可以构造出更复杂的存储结构。语言级存储描述可经编译器转换成机器级，因此
也可以看成是一种机内表示。本书主要在语言级（类C语言）上讨论存储结构。
知识点4运算
运算是指在某种逻辑结构上施加的操作，即对逻辑结构的加工。这种加工以数据的逻辑结构为对象。
一般来说，在每个逻辑结构上，都定义了一组基本运算，这些运算包括：建立、查找、读取、插入和删除等。
从数据结构的定义可看出，应该将数据的逻辑结构、对数据的操作（基本运算集合）以及数据的存储
结构联系在一起，作为一个整体来看待。线性表、栈和队列中的元素具有相同的逻辑结构（即线性结构），
但有不同的运算集，它们是不同的数据结构。本书在介绍各种数据结构时，将同时描述其逻辑结构、对应
的一组基本运算和其可以采用的存储结构。
【考点练习】
【真题·单选】与数据元素本身的形式、内容、相对位置、个数无关的是数据的（）。
A.存储结构 B.逻辑结构
C.类型 D.运算实现
【答案】B
【解析】数据元素之间的逻辑关系的整体就称为数据的逻辑结构，其与数据元素本身的形式、内容、相对
位置、个数无关。
【真题·单选】不属于数据组织三个层次的是（）。
A.数据 B.数据元素
C.数据类型 D.数据项

=== 第 13 页 ===
第一章概论
第9页【答案】C
【解析】从宏观上看，数据、数据元素和数据项实际上反映了数据组织的三个层次。
【真题·填空】在数据库中数据项又称为字段或______。
【答案】域
第三节算法及描述
运算的实现是指该运算的算法。算法是计算机科学的一个基本概念，也是程序设计的一个核心概念。
一个算法规定了求解给定问题所需的处理步骤及其执行顺序，使得给定问题能在有限时间内被求解。
算法可以用某种语言加以描述。本书采用类C语言来描述算法，以简化算法描述。下面简单介绍类C
语言的一些基本语法。
（1）函数描述形式
函数类型函数名（函数参数表）
//算法说明
{
语句序列
}
（2）输入、输出语句
输入语句：scanf（格式,变量1,…,变量n);
输出语句：printf（格式串,变量1,…,变量n）;
（3）赋值语句
变量名=表达式;
（4）选择语句
①条件语句：
if（表达式）语句;
或
if（表达式）语句;
else语句;
②分支语句：
switch
{case条件1:语句序列;break;

=== 第 14 页 ===
《数据结构导论》学习规划卡
第10页case条件2:语句序列;break;
…
case条件n:语句序列;break;
default:语句序列;
}
其中“default：语句序列；”可以省略。
（5）循环语句
for（赋初值表达式序列;条件;修改表达式序列）语句；
while（条件）语句;
do{
语句;
}while（条件）;
（6）结束语句
①函数结束语句：return表达式；
②case结束语句：break；
③异常结束语句：exit（异常代码）；
（7）出错语句error（"错误描述"）
（8）注释
单行注释：//注释内容
多行注释：/*注释内容*/
第四节算法分析
►知识体系
一个问题可以有多种不同的求解算法，这就产生了如何评价这些算法的问题。通常评价算法好坏的因
素包括以下几个方面：

=== 第 15 页 ===
第一章概论
第11页（1）正确性：能正确地实现预定的功能，满足具体问题的需要。
（2）易读性：易于阅读、理解和交流，便于调试、修改和扩充。
（3）健壮性：即使输入非法数据，算法也能适当地做出反应或进行处理，不会产生预料不到的运行结果。
（4）时空性：一个算法的时空性是指该算法的时间性能（或时间效率）和空间性能（或空间效率），
前者是算法包含的计算量，后者是算法需要的存储量。
知识点1时间复杂度【单选、算法设计】★★★
【例1-4】编制函数求1！+2！+…+n！。
【分析】对于这个问题，可以写出两个算法，如图1-7所示。
两个算法的计算量不同，主要区别如下：
fact1函数包含了二重循环，内循环求出i!，外循环中i从1变到n，求出1!+2!+…+n!。fact2函数只包
含一重循环，求i!时借助（i-1）!，即i!=i*（i-1）!。可以看出，在相同的硬、软件环境下，前者花费的运
行时间比后者多，也就是说后者的时间性能比前者好。
如何估算算法的计算量？可在算法中合理地选择一种或几种操作作为“基本操作”，对给定的输入，
确定算法共执行了多少次基本操作，可将基本操作次数作为该算法的时间度量。
对于例1-4中的问题，可分别取乘法、加法和赋值为基本操作，当n=5时，两个函数的计算量见表1-2。
可以看出，选择乘法、加法和赋值语句为基本操作，可反映这两个函数在时间性能上的差异。以乘法作为
基本操作，fact1算法中乘法操作执行次数为1+2+3+…+n=n(n+1)/2，它与n2成正比，fact2算法的中乘法操
作执行次数为1+1+1+…+1=n，它与n成正比。

=== 第 16 页 ===
《数据结构导论》学习规划卡
第12页
假如问题的输入规模为n，一般情况下，一个算法的计算量是问题规模n的函数。设函数factl中乘法、
加法和赋值的次数记为T(n)，则
T(n)=n(n+1)/2+n+n(n+1)/2+2n+1=2(n²+n)/2+3n+1=n2+4n+1
当n充分大时，n2这一项对T(n)的值起着支配作用，采用数学记号O(n2)表示T(n)的近似值，写为
T(n)=O(n2)，这种表示法称为大O表示法，它的含义是：当n充分大时，算法的执行时间与n2成正比。
大O表示法的具体提法是：当且仅当存在正常数c和n0，使得
T(n)≤cf（n）
对所有n>n0成立。其中，f(n)为问题规模n的某个函数。大O表示法也称渐进表示法，它不考虑具体
的运行时间，只给出算法在问题规模n下执行时间的上界。T(n)=O(f(n))称为算法的渐进时间复杂度，简称
时间复杂度。
对函数fact2，时间复杂度T(n)=2n+2=O(n)，当n充分大时，算法的执行时间与n成正比。
【例1-5】对一个n×n阶矩阵进行转置，算法如图1-8所示，分析该算法的时间复杂度。
【分析】习惯上，以方阵阶数n作为输入规模，算法中外循环i的取值从0到n-1，当i=0时，内循环
的次数为0；当i=1时，内循环的次数为1；…；当i=n-1时，内循环的次数为n-1；所以内循环的总次数为：
0+1+2+…+n-1=n(n-1)/2，每次内循环都执行3条赋值语句，这里假定以赋值语句为基本操作，所以该算法
基本操作次数：T(n)=3n(n-1)/2。T(n)=3n(n-1)/2与n²成正比，矩阵转置算法MM的时间复杂度为O(n2)。


=== 第 17 页 ===
第一章概论
第13页时间复杂度常见的阶数有常数阶O(1)（即算法的时间复杂度与输入规模n无关）；对数阶O(log2n)、线
性阶O(n)、多项式阶O(nC)和指数阶O(Cn)，C为大于1的正整数。常见的多项式阶有O(n²)和O(n³)，常见
的指数阶有O(2n)。通常认为，时间复杂度具有指数阶的算法是实际不可计算的，而阶数低于平方阶的算法
是高效率的。
考虑到一个算法对具有相同输入数据量的不同输入数据，时间复杂度可能会不同。通常还可以用最坏
时间复杂度和平均时间复杂度来度量算法的性能。
最坏时间复杂度是指，对相同输入数据量的不同输入数据，算法时间用量的最大值。
平均时间复杂度是指，对所有相同输入数据量的各种不同输入数据，算法时间用量的平均值。
为了比较不同量级时间复杂度的差异，表1-3给出了具有不同时间复杂度阶数f(n)在每秒20亿个程序
步的计算机上运行所需要的时间。（1s=103ms=106μs，执行每一步所需要的时间为0.5×10-9s=0.0005μs。）
从表1-3中可以看出，对于合理大的n，只有时间复杂度较小（如n，nlog2n，n2，n3）的算法是实用的。
知识点2空间复杂度【填空、算法设计】★★
存储量和空间复杂度的概念与计算量和时间复杂度的概念类似，一个算法的空间复杂度定义为该算法
所耗费的存储空间，它也是问题规模n的函数。通常可记为：
S(n)=O(g(n))
其中，g(n)为问题规模n的某个函数。
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在执行期间所需要的
存储空间量应包括以下三个部分：
（1）程序代码所占用的空间；
（2）输入数据所占用的空间
（3）辅助变量所占用的空间。
算法在执行过程中，输入数据所占用的空间是由问题决定的，它不随算法的不同而改变。程序代码所
占用的空间对不同的算法来说也不会有数量级的差别。辅助变量占用的空间则由算法决定，有的需要占用
随问题规模n增大而增大的临时空间，有的不随问题的规模而改变。在估算算法空间复杂度时，一般只需
要分析辅助变量所占用的空间。

=== 第 18 页 ===
《数据结构导论》学习规划卡
第14页【例1-6】读入n=100个整数到一个数组中，写出实现将该组数进行逆置的算法，并分析算法的空间复
杂度。
【分析】我们设计出两个略有不同的函数f1和f2。假设100个整数读入到数组a中，算法f1的思想是
分别从数组两端依次将对应数进行交换，即a[i]与a[100－1－i]进行相互交换，i=0～49，算法f2思想是将
数组a先逆置到数组b，再从数组b复制到数组a。算法f1和f2如图1-9所示。
f1所需要的辅助变量为2个整型变量i和temp，与问题的规模无关，其空间复杂度为O(1)。f2所需要
的辅助变量为1个整型变量i和大小为n=100的整型数组b（与问题的规模相关），其空间复杂度为O(n)。
【考点练习】
【真题·单选】时间复杂度的常数阶表示为（）
A.O(1) B.O(n)
C.O(n2) D.O(2n)
【答案】A
【解析】时间复杂度常见的阶数有常数阶O(1)（即算法的时间复杂度与输入规模n无关）
【真题·填空】在估算算法空间复杂度时，一般只需要分析______所占用的空间。
【答案】辅助变量
【真题·算法设计】设计算法在整型数组A[n]中查找值为k的元素，若找到，则输出其位置i(0≤i≤n-1)，否
则输出－1作为标志。
【答案】

=== 第 19 页 ===
第一章概论
第15页


=== 第 20 页 ===
《数据结构导论》学习规划卡
第16页第二章线性表
►知识体系


=== 第 21 页 ===
第二章线性表
第17页►考点透析
知识点 考核要求 考试题型 重点星级
线性表的定义和特征 识记 填空
案例 领会
线性表顺序存储的类型定义 识记 单选、填空 ★
线性表的基本运算在顺序表上的实现 领会
顺序表实现算法的分析 综合应用 单选、填空 ★
单链表的类型定义 识记 单选、填空 ★
线性表的基本运算在单链表上的实现 简单易用 单选、填空 ★★
建表 领会
删除重复结点 领会
循环链表 识记 填空
双向循环链表 识记 单选 ★
顺序实现与链接实现的比较 领会

=== 第 22 页 ===
《数据结构导论》学习规划卡
第18页第一节线性表的基本概念
►知识体系
知识点1线性表的定义和特征【填空】
（1）定义
线性表（LinearList）是一种线性结构，它是由n（n≥0）个数据元素组成的有穷序列，数据元素又称
结点。结点个数n称为表长。当n=0时，线性表不含任何数据元素，称为空表，记为()或
。当n>0时，线
性表通常表示成（a1，a2，…，an），a1称为起始结点，an称为终端结点。对任意一对相邻结点ai和ai+1（l
≤i<n），ai称为ai+1的直接前驱，ai+1称为ai的直接后继。
（2）基本特征
线性表中结点具有一对一的关系，如果结点数不为零，则除起始结点没有直接前驱外，其他每个结点
有且仅有一个直接前驱；除终端结点没有直接后继外，其他每个结点有且仅有一个直接后继。
线性表中，每个数据元素的含义，在不同的应用中各不相同，但同一个线性表中的所有结点代表的数
据元素具有相同的特性。如每个结点表示一个数，或者一名学生的信息，也可以表示更为复杂的信息。
知识点2案例
【例2-1】学生档案信息表。
【分析】在例1-1中介绍的学生档案信息表是线性表，每位学生信息包括学号、姓名、性别、年龄和入
学成绩，每位学生信息构成一个结点，如图2-1所示。其中结点之间连线表示两个结点间一对一的相邻关系。
第一个结点（1001，王韬，男，20，589）无直接前驱，但有一个直接后继（1002，潘小欣，女，21，
580）；最后一个结点（1005，刘勇，男，22，585）有一个直接前驱（1004，赵李军，男，18，580），但

=== 第 23 页 ===
第二章线性表
第19页无直接后继；其他三个结点都有一个直接前驱和一个直接后继。
图2-1的学生档案信息表中有5个结点，所以该表的表长为5。
下面给出线性表基本运算及功能描述。
（1）初始化Initiate(L)：建立一个空表L=()，L不含数据元素。
（2）求表长Length(L)：返回线性表L的长度。
（3）读表元素Get(L，i)：返回线性表第i个数据元素，当i不满足l≤i≤Length(L)时，返回一特殊值。
（4）定位Locate(L，x)：查找线性表中数据元素值等于x的结点序号，若有多个数据元素值与x相等，
运算结果为这些结点中序号的最小值，若找不到该结点，则运算结果为0。
（5）插入Insert(L，x，i)：在线性表L的第i个数据元素之前插入一个值为x的新数据元素，参数i
的合法取值范围是1≤i≤n+1。操作结束后线性表L由（a1，a2，…，ai-1，ai，ai+1，…，an）变为（a1，a2，…，
ai-1，x，ai，ai+1，…，an），表长度加1。
（6）删除Delete(L，i)：删除线性表L的第i个数据元素ai，i的有效取值范围是1≤i≤n。删除后线性
表L由（a1，a2，…，ai-1，ai，ai+1，…，an）变为（a1，a2，…，ai-1，ai+1，…，an），表长度减1。
对于不同的存储结构，这些基本运算的实现细节是不同的。
【考点练习】
【真题·填空】线性表中如果结点数不为零，则除起始结点没有直接前驱外，其他每个结点有且仅有______
个直接前驱。
【答案】1
第二节线性表的顺序存储
►知识体系


=== 第 24 页 ===
《数据结构导论》学习规划卡
第20页知识点1线性表顺序存储的类型定义【单选、填空】★
线性表顺序存储的方法是：将表中的结点依次存放在计算机内存中一组连续的存储单元中，数据元素
在线性表中的邻接关系决定它们在存储空间中的存储位置，即逻辑结构中相邻的结点其存储位置也相邻。
用顺序存储实现的线性表称为顺序表。一般使用数组来表示顺序表。
假定线性表的数据元素的类型为DataType（可以根据实际问题中的数据元素特征进行定义），顺序表
的结构定义如下：
预先定义一个足够大的常量Maxsize，作为数组的最大长度。数据域data是一个一维数组，线性表的n
个元素分别存放在此数组的第0～(length-1)单元中，如图2-2所示。常量Maxsize表示顺序表的容量，在图
2-2中，从length到Maxsize-1为顺序表当前的空闲区，直观上可以看出，该分配给顺序表的空间未完全使用。
将上述定义存放到头文件到LinearL.h中。
【例2-2】学生档案信息表的顺序存储实现。
【分析】根据学生档案信息，给出顺序表具体的类型定义。


=== 第 25 页 ===
第二章线性表
第21页根据上述定义，该顺序表的名称为student，表的最大长度为7，表的实际长度值在student.length中。
顺序表student的顺序存储如图2-3所示。在当前状态下，学生档案信息顺序表中共有5个数据元素，分别
为student.data[0]、student.data[1]、student.data[2]、student.data[3]和student.data[4]，表的实际长度是5，也
即student.length=5，student.data[5]和student.data[6]目前处于空闲状态。
知识点2线性表的基本运算在顺序表上的实现
（1）插入
顺序表的插入运算InsertSeqlist(SeqListL，DataTypex，inti)是指在顺序表的第i（1≤i≤n+1）个元素
之前，插入一个新元素x。使长度为n的线性表(a1，a2，…，ai-1，ai，…，an)变为长度为n+1的线性表(a1，
a2，…，ai-1，x，ai，…，an)。
插入算法的基本步骤是：首先将结点ai~an依次向后移动一个元素的位置，这样空出第i个数据元素的
位置；然后将x置入该空位，最后表长加1。由顺序表的存储特点可知，元素的移动只能按an，an-1，…，
ai的次序进行，即按从右到左的次序先将an右移一位，再将an-1右移一位到an原来的位置上，依次类推，直
到将ai右移到ai+1原来的位置上。具体的插入算法描述如下：
顺序表中结点的物理顺序和线性表中结点的逻辑顺序保持一致，插入元素前、后顺序表的状况如图2-4
所示。

=== 第 26 页 ===
《数据结构导论》学习规划卡
第22页
（2）删除
删除运算DeleteSeqlist(SeqListL，inti)是指将线性表的第i（1≤i≤n）个数据元素删去，使长度为n的
线性表(a1，a2，…，ai-1，ai，ai+1，…，an)变为长度为n-1的线性表(a1，a2，…，ai-1，ai+1，…，an)。
和插入运算类似，删除运算也要移动结点，结点间逻辑关系发生变化。如果i的值合法，当1≤i≤n-1
时，将原表中第i+1，i+2，…，n个元素依次向左移动一个元素位置，以填补删除操作造成的空缺。当i=n

=== 第 27 页 ===
第二章线性表
第23页时，直接将表长度减1即可。顺序表删除元素前、后的状况如图2-5所示。
删除运算的基本步骤是：①结点ai+1，…，an依次向左移动一个元素位置（从而覆盖掉被删结点ai）；
②表长度减1。此处无需考虑溢出，只判断参数i是否合法即可。算法描述如下：
（3）定位
定位运算LocateSeqlist(SeqListL，DataTypex)的功能是查找出线性表L中值等于x的结点序号的最小
值，当找不到值为x的结点时，返回结果0。下列算法从左往右扫描顺序表中的元素，考察元素的值是否等
于x，描述算法如下：
在上述算法中，i从0开始，作为扫描顺序表时的下标。如果表L中有一个结点的值等于x，或i等于
L.length，则终止while循环。若while循环终止于i等于L.length，则未找到值为x的元素，返回0，否则
返回值为x的元素的位置。
顺序表的求表长操作Length(L)，直接输出L.length即可。
知识点3顺序表实现算法的分析【单选、填空】★
从算法的实现中可以看出，在线性表的基本操作中，最频繁的操作是数据元素的比较和移动。因此我
们在分析线性表的顺序表实现算法时，一个重要指标就是数据元素的比较和移动的次数。
设表的长度length=n，在插入算法中，元素的移动次数不仅与顺序表的长度n有关，还与插入的位置i
有关。当插入位置i=n+1时，需要比较和移动元素的次数为0；当i=1时，需要比较和移动元素的次数是n。
由此可见，插入算法在最坏情况下，其时间复杂度为O(n)。一般情况下元素比较和移动的次数为n-i+1次，
对于i=1，2，…，n+1这n+1种不同的情况，计算元素的移动次数，可以得出插入算法的平均移动次数约
为n/2，其时间复杂度是O(n)。

=== 第 28 页 ===
《数据结构导论》学习规划卡
第24页通过以上的分析易知，在顺序表上做插入运算平均要移动表中一半的结点。当n很大时，算法的效率
较低。
用上述方法分析删除算法DeleteSeqlist，可得其在最坏情况下元素移动次数为n-1，时间复杂度为O(n)，
元素平均移动次数约为
，时间复杂度为O(n)。
对于定位算法，需要扫描顺序表中的元素。以参数x与表中结点值的比较为标准操作，平均时间复杂
度为O(n)。求表长和读表元素算法的时间复杂度为O(1)，就阶数而言，已达到最低。
通过以上分析可知，顺序表的插入、删除算法在时间性能方面是不理想的。
【考点练习】
【真题·单选】线性表实现顺序存储可使用（）。
A.栈 B.队列
C.数组 D.链表
【答案】C
【解析】一般使用数组来表示顺序表。
【真题·单选】设顺序表有9个元素，则在第3个元素前插入一个元素所需移动元素的个数为（）。
A.5 B.6
C.7 D.9
【答案】C
【解析】一般情况下元素比较和移动的次数为n-i+1次，即n-i+1=9-3+1=7次。
【真题·填空】在顺序表上做插入运算平均要移动表中______的结点。
【答案】一半

=== 第 29 页 ===
第二章线性表
第25页第三节线性表的链接存储
►知识体系
线性表的链接存储是指它的存储结构是链式的。线性表常见的链式存储结构有单链表、循环链表和双
向循环链表，其中最简单的是单链表。
知识点1单链表的类型定义【单选、填空】★
【例2-3】日常生活中常见的交通工具——火车，它是由各节车箱连接起来组成的，在图2-6中，每节
车箱都有一个车钩勾住下一节车箱，这样完成车箱的连接。这里的车钩相当于单链表中的指针。
如果把车钩看成是车厢的一个组成部分，则和火车类似，单链表就是线性表的数据元素（相当于车厢）
用指针（相当于车钩）链接起来的存储结构，指针表示数据元素之间的逻辑关系。一个数据元素和一个指
针组成单链表的一个结点，如图2-7所示。各个结点在内存中的存储位置并不一定连续，可存放在内存的不
同位置。链表的结点可以重新链接，相当于火车编组。
在图2-7中，data部分称为数据域，用于存储线性表的一个数据元素，next部分称为指针域或链域，用
于存放一个指针，该指针指向本结点所含数据元素的直接后继结点。
所有结点通过指针链接形成链表(LinkList)，如图2-8所示。head称为头指针变量，该变量的值是指向
单链表的第一个结点的指针。可以用头指针变量来命名单链表，图2-8中的单链表称为“表head”或“head
表”。链表中第一个数据元素结点称为链表的首结点，它相当于火车的第一节车厢，链表中最后一个数据

=== 第 30 页 ===
《数据结构导论》学习规划卡
第26页元素结点称为尾结点或终端结点，它相当于火车的最后一节车厢。在图2-8a中，数据元素a1所在的结点是
首结点，数据元素an所在的结点是尾结点。尾结点指针域的值NULL称为空指针，它不指向任何结点，表
示链表结束。如果head等于NULL，则表示该链表无任何结点，是空单链表，如图2-8b所示。这里要说明
的是头指针变量不一定非要用head来标识，根据需要任何一个合法的标识符都可以标识头指针。
单链表的类型定义如下：
可以将上述定义存放到头文件到LinearL.h中。
在上述定义中，structnode表示链表的结点，结点包含两个域：数据域（data）和指针域（next）。数
据域的类型为DataType，指针域存放该结点的直接后继结点的地址，类型为指向structnode的指针。定义
中通过typedef语句把structnode类型定义为Node，把structnode指针类型定义为LinkList，这是为了后面
算法描述的简洁和讨论的方便。在以后的讨论中，我们常用LinkList来表示一个链表类型，而LinkList的实
质是该链表的头指针类型，正如前文所述，我们通常用头指针来表示一个单链表。
将上述定义添加到头文件LinearL.h中。
【例2-4】给出图2-1中学生档案信息表的链接存储实现。
【分析】用结构体描述该档案信息表的每个数据元素的类型，即描述DataType的具体类型，再描述出
单链表类型，通过指针连接每个数据元素。
【解】学生档案信息链表的类型完整描述如下：

=== 第 31 页 ===
第二章线性表
第27页
根据上述定义知道该链表的名称为head。在图2-9中，head链表的每个结点包含有数据域和指针域，
指针域存放的是下一个结点的地址。数据域为（1001，王韬，男，20，589）的结点是首结点，它没有直接
前驱结点，它和数据域为（1002，潘小欣，女，21，580）的结点在逻辑结构上相邻，在存储结构上，这两
结点地址不一定相邻，但（1002，潘小欣，女，21，580）的结点地址存放在（1001，王韬，男，20，589）
的结点的next域中。同理每个结点的地址存放在其直接前驱结点的next域中，相当于一个钩子勾住其直接
后继结点。数据域为（1005，刘勇，男，22，585）的结点是尾结点，它没有直接后继结点，它的next域的
值为NULL。head是链表的头指针，通过它并沿着每个结点的next域可依次找到所有的结点。
为了便于运算的实现，在单链表的第一个结点之前增设一个类型相同的结点，称之为头结点，其他结
点称为表结点。表结点中的第一个和最后一个结点分别就是首结点和尾结点，如图2-10所示。头结点的数
据域可以不存储任何信息，也可以存放一个特殊标志或表长，也可以根据算法的需要定义。以下的讨论中，
若无特别说明，采用的都是带头结点的单链表。

=== 第 32 页 ===
《数据结构导论》学习规划卡
第28页
知识点2线性表的基本运算在单链表上的实现【单选、填空】★★
（1）初始化
InitiateLinkList的功能是建立一个如图2-10b所示的空表。空表由一个头指针和一个头结点组成。因此
初始化一个单链表首先需要创建一个头结点并将其指针域设为NULL（表示该结点不指向任何结点），然
后用一个LinkList类型（即结点的指针类型）的变量指向新创建的结点。这个LinkList类型的变量就作为链
表的头指针。
算法描述如下：
在算法中，变量head是链表的头指针，它指向新创建的结点，即头结点。依据前面的讨论，一个空单
链表仅有一个头结点，它的指针域为NULL。
（2）求表长
在单链表存储结构中，线性表的表长等于单链表中数据元素的结点个数，即除了头结点以外的结点的
个数。图2-11所示为数据域为整数的单链表，其表长为4。
通常通过头指针head来访问一个单链表，单链表的结点通过指针域来维持与直接后继的关系。因此，
只能通过结点的指针域来从头至尾访问每一个结点。求表长的算法也是来源于这个思路。设置一个工作指

=== 第 33 页 ===
第二章线性表
第29页针p，初始时，p指向头结点，并设置一个计数器cnt，初值设置为0。然后，让工作指针p通过指针域逐个
结点向尾结点移动，工作指针每向尾部移动一个结点，让计数器加1。这样，直到工作指针p->next为NULL
时，说明已经走到了表的尾部，这时已完成对所有结点的访问，计数器cnt的值即是表的长度。
算法描述如下：
（3）读表元素
通常给定一个序号i，查找线性表的第i个元素。在链表中，任何相邻的两个结点通过一个指针相连，
一个结点的位置包含在直接前驱结点的next域中。所以，必须从头指针出发，一直往后移动，直到第i个
结点。这和求表长算法相似。
单链表的读表元素算法描述如下：
注意：p!=NULL在这里作为判断是否已遍历整个链表的条件，不可遗漏。
（4）定位

=== 第 34 页 ===
《数据结构导论》学习规划卡
第30页线性表的定位运算，就是对给定表元素的值，找出这个元素的位置。在单链表的实现中，则是给定一
个结点的值，找出这个结点是单链表的第几个结点。定位运算又称作按值查找。
在定位运算中，也需要从头至尾访问链表，直至找到需要的结点，返回其序号。若未找到，返回0。
定位运算算法描述如下：
（5）插入
单链表的插入运算是将给定值为x的元素插入到链表head的第i个结点之前。要实现这个算法，先找
到链表的第i-1个结点q，然后，生成一个值为x的新结点p，p的指针域指向q的直接后继结点，q的指针
域指向p，这样即完成单链表的插入运算，插入结点的指针变化如图2-12所示。
插入运算描述如下：


=== 第 35 页 ===
第二章线性表
第31页值得注意的是，链接操作p->next=q->next和q->next=p两条语句的执行顺序不能颠倒，否则结点*q的
链域值（即指向原表第i个结点的指针）将丢失。
（6）删除
删除运算是给定一个值i，将链表中第i个结点从链表中移出，并修改相关结点的指针域，以维持剩余
结点的链接关系。如图2-13所示，将ai结点移出后，需要修改该结点的直接前驱结点ai-1的指针域，使其
指向移出结点ai的直接后继结点。
单链表的删除运算算法描述如下：
注意，表面上看，如果没有free(p)这条语句，也可以将结点从链表中移出，移出操作是通过修改指针
的指向关系来实现的。实际上，free(p)是必不可少的，因为当一个结点从链表移出后，如果不释放它的空间，
它将变成一个无用的结点，它会一直占用着系统内存空间，其他程序将无法使用这块空间。
【考点练习】
【真题·单选】线性表采用链表存储结构时，内存中可用存储单元的地址（）。
A.必须是连续的 B.部分必须是连续的

=== 第 36 页 ===
《数据结构导论》学习规划卡
第32页C.定是不连续的 D.连续不连续都可以
【答案】D
【解析】线性表的链接存储是指它的存储结构是链式的。但各个结点在内存中的存储位置并不一定连续，
可存放在内存的不同位置。
【真题·填空】在单链表存储结构中，线性表的表长等于单链表中______的结点个数。
【答案】数据元素
【真题·填空】在单链表中，指针p所指的结点为最后一个结点的条件是______。
【答案】p->next==NULL
第四节其他运算在单链表上的实现
►知识体系
知识点1建表
根据线性表元素的邻接关系，建立该线性表的单链表。我们讨论建立含头结点的单链表。这个过程分
为三步：首先建立带头结点的空表；其次建立一个新结点，然后将新结点链接到头结点之后，这个结点为
尾结点（也是首结点）；复建立新结点和将新结点链接到表尾这两个步骤，直到线性表中所有元素链接到
单链表中。这里用int代替DataType。
方法一：通过已实现的插入算法InsertLinklist(LinkListhead，intx，inti)来实现，依次增大插入位置i，
使新的结点链入到链表中。

=== 第 37 页 ===
第二章线性表
第33页
算法InsertLinklist主要部分是找到第i个位置，然后将新结点插入，它的计算量约等于i。在这里，若
线性表有n个元素，插入位从1到n，因此，上述建表算法的计算量约
 ，其时间
复杂度为O(n²)。
方法二：上面的算法由于每次插入都从表头开始查找，比较浪费时间。因为每次都是把新的结点链接
到表尾，我们可以用一个指针指向尾结点，这样就为下一个新结点指明了插入位置。
方法中的链接操作如图2-14所示。它的时间与元素个数成正比，故其时间复杂度为O(n)，比前一个算
法快。

=== 第 38 页 ===
《数据结构导论》学习规划卡
第34页方法三：
方法三的操作如图2-15所示。它的时间复杂度也是O(n)，该方法始终将新增加的结点插入到头结点之
后，第一个数据结点之前，可称之为“前插”操作。用方法二建立的链表，最终形成的链表的数据顺序与
输入顺序相同，用方法三建立的链表，最终形成的链表的数据顺序与输入顺序正好相反。
知识点2删除重复结点
在线性表中，可能有多个结点的元素值是相同的，它们是重复结点。可以设计算法删除重复结点，只
保留结点序号最小的那个结点。例如，线性表(4，7，2，5，2，4)，删除重复结点后结果为(4，7，2，5)。

=== 第 39 页 ===
第二章线性表
第35页对每一个结点，在表中查找是否有相同的元素值结点，算法粗略地描述如下：
其中“删除ai+1，…，an中值等于ai的结点”的算法进一步描述如下：
用链表作为存储结构，细化上述算法得到最后的算法描述：
为了便于删除操作，p指针始终指向“当前比较结点”的前驱结点，如图2-16所示。

=== 第 40 页 ===
《数据结构导论》学习规划卡
第36页
第五节其他链表
►知识体系
知识点1循环链表【填空】
在单链表中，如果让最后一个结点的指针域指向第一个结点可以构成循环链表。在循环链表中，从任
一结点出发能够扫描整个链表。
图2-17给出常见的循环链表，图2-17a、b分别表示带头结点的非空循环链表和空循环链表，头指针是
head。在这种结构下，要找到尾结点可以从头指针head出发扫描所有的结点。在图2-17c、d中，链表没有
设头指针，只设尾指针rear。这样，首结点表示为：rear->next->next，首、尾结点都能方便地访问。

=== 第 41 页 ===
第二章线性表
第37页
在循环链表上实现线性表的运算与在单链表上实现线性表的运算十分类似。
知识点2双向循环链表【单选】★
在单链表的每个结点中再设置一个指向其直接前驱结点的指针域prior，这样每个结点有两个指针，其
结点结构如图2-18所示。
prior与next类型相同，它指向直接前驱结点。头结点的prior指向最后一个结点，最后一个结点的next
指向头结点，由这种结点构成的链表称为双向循环链表如图2-19所示。


=== 第 42 页 ===
《数据结构导论》学习规划卡
第38页双向循环链表与单链表类似，用类C语言描述如下：
单链表允许从一个结点直接访问它的后继结点，所以，找直接后继结点的时间复杂度是O(1)，双向循
环链表是一种对称结构，既可以直接访问前驱结点又可以直接访问后继结点，找前驱结点和后继结点的时
间复杂度均为O(1)。双向循环链表适合应用在需要经常查找结点的前驱和后继的场合。
双向循环链表的对称性可以用下列等式表示：
p=p->prior->next=p->next->prior
结点p的前驱结点的next和后继结点的prior都指向结点p。
双向循环链表的基本运算：
求表长、定位、按序号查找等运算和prior指针的关系不大，双向循环链表上这些运算的实现和单链表
基本相同。下面讨论它的插入和删除操作。
（1）删除
在单链表中删除结点时，需要用一个指针指向待删结点的前驱结点，在双循环链表中，设p指向待删
结点，删除*p可通过下述语句完成，执行效果如图2-20所示。
①p->prior->next=p->next; //p前驱结点的后链指向p的后继结点
②p->next->prior=p->prior; //p后继结点的前链指向p的前驱结点
③free(p); //释放*p的空间
①②这两个语句的执行顺序可以颠倒。
（2）插入
在p所指结点的后面插入一个新结点*t，需要修改四个指针；

=== 第 43 页 ===
第二章线性表
第39页①t->prior=p;
②t->next=p->next;
③p->next->prior=t;
④p->next=t;
插入操作过程如图2-21所示，注意这些语句之间的顺序。
【考点练习】
【真题·单选】双向循环链表的对称性可以表示为（）。
A.p=p->prior->next=p->next->priorB.p=p->next=p->prior
C.p=p->next->next=p->prior->priorD.p=p->next->next=p->next
【答案】A
【解析】双向循环链表的对称性可以用下列等式表示：p=p->prior->next=p->next->prior
【真题·单选】双向循环链表结点结构为（）
A.data、next、node B.prior、data、next
C.rear、data、next D.prior、data、rear
【答案】B
【解析】
双向循环链表结点结构

=== 第 44 页 ===
《数据结构导论》学习规划卡
第40页【真题·填空】在单链表中，如果让最后一个结点的指针域指向第一个结点可以构成_______链表。
【答案】循环
第六节顺序实现与链接实现的比较
线性表的顺序实现和链接实现都有各自的特点，本节对这两种结构的时间性能和空间性能进行比较。
（1）对于按位置查找运算，顺序表是随机存取，时间复杂度为O(1)。单链表需要对表元素进行扫描，
它时间为复杂度为O(n)。
（2）对于定位运算，基本操作是比较，顺序表和单链表上的实现算法的时间复杂度是相同的，均为
O(n)。
（3）对于插入、删除运算，在顺序表和链表中，都需要进行定位。在顺序表中，其基本操作是元素的
比较和结点的移动，平均时间复杂度为O(n)。在单链表中，由于需要定位，基本操作是元素的比较，尽管
不需要移动结点，其平均时间复杂度仍然为O(n)。
总之，线性表的顺序实现与链接实现各有其优缺点，不能笼统地说哪种实现更好，只能根据实际问题
的具体需要，并对各方面的优缺点加以综合平衡，最终选定比较适宜的实现方法。
单链表的每个结点包括数据域与指针域，指针域需要占用额外空间。
从整体考虑，顺序表要预分配存储空间，如果预先分配得过大，将造成浪费，若分配得过小，又将发
生上溢；单链表不需要预先分配空间，只要内存空间没有耗尽，单链表中的结点个数就没有限制。
【考点练习】
【真题·单选】下列关于线性表的顺序实现和链接实现特点的描述，错误的是（）。
A.顺序表不需要预先分配存储空间
B.单链表的指针域需要占用额外空间
C.对于定位运算，顺序表和单链表上的实现算法的时间复杂度相同
D.对于插入、删除运算，在顺序表和链表中，都需要进行定位
【答案】A
【解析】从整体考虑，顺序表要预分配存储空间，如果预先分配得过大，将造成浪费，若分配得过小，又
将发生上溢。

=== 第 45 页 ===
第三章栈、队列和数组
第41页第三章栈、队列和数组
►知识体系


=== 第 46 页 ===
《数据结构导论》学习规划卡
第42页►考点透析
知识点 考核要求 考试题型 重点星级
栈的基本概念 识记 填空
栈的顺序实现 简单易用 单选、应用 ★★
栈的链接实现 简单易用 单选、填空、应用 ★★★
栈的简单应用和递归 综合应用 单选
队列的基本概念 识记 单选、填空 ★
队列的顺序实现 简单易用 单选、填空、算法设计 ★★★
队列的链接实现 领会 填空 ★
队列应用 领会
数组的逻辑结构和基本运算 识记 填空
数组的存储结构 识记 单选 ★
矩阵的压缩存储 简单易用 单选、填空、应用 ★★★
案例 领会
命令含义规定 领会

=== 第 47 页 ===
第三章栈、队列和数组
第43页第一节栈
►知识体系
栈和队列可看作是特殊的线性表。它们的特殊性表现在它们的基本运算是线性表运算的子集，它们是
运算受限的线性表。栈和队列是计算机科学中使用得较为广泛的两种结构。
知识点1栈的基本概念【填空】
（1）栈的基本概念
栈（Stack）是运算受限的线性表，这种线性表上的插入和删除运算限定在表的某一端进行。允许进行
插入和删除的一端称为栈顶，另一端称为栈底。不含任何数据元素的栈称为空栈。处于栈顶位置的数据元
素称为栈顶元素。
（2）例子
【例3-1】饭店里，服务员要洗盘子，洗好的盘子摞在桌子上，每洗一个摞上一个，厨师使用盘子时，
总是从最上面取走一个，假定①每次只能摞上一个盘子；②每次只能取走最上面的一个盘子。桌上的这叠
盘子具有栈的结构特征。图3-1表示桌子上有四个盘子的状态。


=== 第 48 页 ===
《数据结构导论》学习规划卡
第44页【分析】在图3-1所示的状态下，桌面是栈底，D盘在栈顶，A盘在栈底，D盘在最上面，先被取走，
才能依次取走C盘、B盘、A盘。
盘子摞放和取走可看作栈的插入、删除运算。插入、删除都在栈顶进行，相当于进出都要经过盘子堆
的上端，在摞放和取走这个动态过程中，先放上的盘子后使用，后放上的盘子先使用。栈的修改原则是后
进先出（LastInFirstOut），因此，栈又称为后进先出线性表，简称后进先出表。栈的插入和删除运算分别
称为进栈和出栈。
（3）栈的基本运算
①初始化InitStack(S)：构造一个空栈S；
②判栈空EmptyStack(S)：若栈S为空栈，则结果为1，否则结果为0；
③进栈Push(S，x)：将元素x插入栈S中，使x成为栈S的栈顶元素；
④出栈Pop(S)：删除栈顶元素；
⑤取栈顶GetTop(S)：返回栈顶元素。
知识点2栈的顺序实现【单选、应用】★★
栈的顺序存储结构是用一组连续的存储单元依次存放栈中的每个元素，并用始端作为栈底。栈的顺序
实现称为顺序栈。通常用一个一维数组和一个记录栈顶位置的变量来实现栈的顺序存储。在图3-2中，用一
个长度为6的数组S[6]和一个变量top，说明栈顶top与栈内数据元素变化的状态。
图3-2a表示一个空栈，栈初始化运算得到一个空栈，此时，栈顶下标值top=0，如果此时做出栈运算，
则产生“下溢”。
图3-2b是在图3-2a状态下，将20进栈，即执行进栈运算Push(S，20)之后得到的状态，栈中有一个元
素20，top的值由0变为1。
图3-2c是在图3-2b的基础上将30进栈，即执行进栈运算Push(S，30)，此时栈顶下标值top=2。
图3-2d是在图3-2c状态下，执行一次出栈运算Pop(S)得到的结果。执行出栈运算后，top值减1，新
的栈顶值top=1。此时，30虽然仍存在数组中，但它已经不是栈的数据元素。
图3-2e是图3-2d状态下连续执行进栈运算Push(S，40)，Push(S，50)，Push(S，60)，Push(S，70)后得

=== 第 49 页 ===
第三章栈、队列和数组
第45页到的结果，图中可以看到，此时，栈中的数据元素已经填满了，如果再进行进栈操作，会发生“上溢”，
为了防止数据丢失，在进栈操作之前应该判断是否栈满。
顺序栈用类C语言定义如下：
将上述定义存放到Seqstack.h中。
maxsize为顺序栈的容量。
data[maxsize]为存储栈中数据元素的数组。
top为标志栈顶位置的变量，常用整型表示，范围为0～（maxsize-1）。
下面列出栈的基本运算在顺序栈上的实现算法。
（1）初始化
（2）判栈空
（3）进栈


=== 第 50 页 ===
《数据结构导论》学习规划卡
第46页（4）出栈
（5）取栈顶元素
【例3-2】在某些应用中，为了节省空间，让两个数据元素类型一致的栈共享一维数组空间data[max]，
成为双栈，两个栈的栈底分别设在数组两端，让两个栈彼此迎面“增长”，两个栈的栈顶变量分别为top1、
top2，仅当两个栈的栈顶位置在中间相遇时(top1+1=top2)才发生“上溢”，双栈如图3-3所示。
【分析】图3-3中斜线部分表示空闲区域，双栈的数据结构定义为：
双栈的操作和单顺序栈操作基本相似，但是判断上溢为top1+1=top2，判栈空时，两个栈不同，当top1=0
时栈1为空栈，top2=max-1时栈2为空栈。

=== 第 51 页 ===
第三章栈、队列和数组
第47页知识点3栈的链接实现【单选、填空、应用】★★★
栈的链接实现称为链栈，链栈可以用带头结点的单链表来实现，如图3-4所示。LS指向链表的头结点，
首结点是栈顶结点，LS->next指向栈顶结点，尾结点为栈底结点。各结点通过链域的连接组成栈，由于每
个结点空间都是动态分配产生，链栈不用预先考虑容量的大小。
链栈用类C语言定义如下：
将上述定义存放到Lkstack.h中。
根据上述类型定义，栈的基本运算在链栈上的实现算法如下。
（1）初始化
初始化时，生成一个结点，将该结点的next域设置为NULL，如图3-5所示。

=== 第 52 页 ===
《数据结构导论》学习规划卡
第48页
（2）判栈空
（3）进栈
在进栈操作算法中采用前插操作，新增结点始终插入到头结点之后，如图3-6所示。


=== 第 53 页 ===
第三章栈、队列和数组
第49页（4）出栈
出栈操作始终是栈顶结点出栈，即删除头结点之后的结点，如图3-7所示。
上面描述了链栈的进栈和出栈的实现算法，现在举例说明这个过程。
【例3-3】设一个链栈的输入序列为A、B、C，试写出所得到的所有可能的输出序列，即输出出栈操作
得到的数据元素的排列。
【分析】共有五种可能的输出序列：
输出ABC，A进，A出，B进，B出，C进，C出；
输出BCA，A进，B进，B出，C进，C出，A出；
输出BAC，A进，B进，B出，A出，C进，C出；
输出CBA，A进，B进，C进，C出，B出，A出；
输出ACB，A进，A出，B进，C进，C出，B出。
图3-8给出第二种情况，输出序列为BCA。

=== 第 54 页 ===
《数据结构导论》学习规划卡
第50页（5）取栈顶元素
知识点4栈的简单应用和递归【单选】
（1）栈的简单应用举例
【例3-4】阅读下列程序片断，写出程序的运行结果。


=== 第 55 页 ===
第三章栈、队列和数组
第51页
【分析】程序中设立了一个顺序栈，栈的元素为字符型，程序先通过for循环语句依次将11个字母'A'～
'K'进栈stk中，同时输出每个字母，然后，用while语句循环判定栈是否为空，若不为空，将stk栈中元素
依次出栈，并依次输出每个栈顶字母，由于栈具有后进先出特征，因此，输出结果与输入数据是反序的，
所以，运行结果如下：
ABCDEFGHIJK
KJIHGFEDCBA
【例3-5】写一个算法，借助栈将图3-9所示的带头结点的单链表逆置。
【分析】将链表逆置，其实是将链表结点中数据元素倒置，由于不知道链表的长度，可以用链栈来实
现。扫描链表，将链表中数据元素依次进栈，然后，再一次扫描链表，同时依次进行出栈操作，将出栈的
元素依次填到链表中去。
算法描述如下：

=== 第 56 页 ===
《数据结构导论》学习规划卡
第52页
（2）递归与栈
栈是一种应用范围广泛的数据结构，适用于各种具有“后进先出”特征的问题。这里着重讨论栈与函
数调用，特别是与递归调用之间的关系，力图在说明如何用栈解决实际问题的同时阐明递归的基本概念，
这一概念是下一章的重要基础。
递归是一个重要的概念，同时也是一种重要的程序设计方法。简单地说，如果在一个函数或数据结构
的定义中又应用了它自身（作为定义项之一），那么这个函数或数据结构称为是递归定义的，简称递归的。
例如，阶乘函数可递归定义如下：
阶乘函数递归定义中，求n!问题转换成求n*(n-1)!问题，继续利用递归定义，求n*(n-1)!问题转换成求
n*(n-1)*(n-2)!问题，……，求n*(n-1)*(n-2)*…*2!问题转换成求n*(n-1)*(n-2)*…*2*1!，最后转换成求
n*(n-1)*(n-2)*…*2*1*0!，根据上述定义，当n=0时，n!=1，这样，这个递归定义与n!=n*(n-1)*(n-2)…*2*1
的定义是一致的。
递归定义不能是“循环定义”。为此要求任何递归定义必须同时满足如下两个条件：
①被定义项在定义中的应用（即作为定义项的出现）具有更小的“规模”；
②被定义项在最小“规模”上的定义是非递归的，这是递归的结束条件。
在上述阶乘函数的定义中，定义n!，又用了(n-1)!，它具有比原来（即n）更小的“规模”（即n-1）。
同时，n!在最小“规模”（即0）上的定义是非递归的（由自然数1直接定义），即当n=0时，n!=1是递归
的结束条件。这两个条件构成了递归算法的基本成分。此外，通常将反映条件②的部分写在递归函数的开头。
很多实际问题是递归定义的。对于这些问题，很容易用类C语言写出求解它们的递归算法。计算阶乘

=== 第 57 页 ===
第三章栈、队列和数组
第53页函数的递归算法描述如下：
下面通过用递归函数求n!的完整程序来说明递归函数的执行过程。
程序的执行过程如图3-10所示。设主函数main中n=3，即要求3!。
从图3-10可以看出，函数调用的顺序是：f(3)、f(2)、f(1)、f(0)，而求出阶乘值的顺序依次是0!、1!、2!
和3!，程序返回的顺序是依次返回到f(0)、f(1)、f(2)和主函数main()，函数调用的顺序与返回的顺序正好相
反，这个过程具有栈的后进先出特征。
递归函数的运行引起递归调用。为了保证在不同层次的递归调用能正确地返回，必须将每一次递归调
用的参数和返回地址保存起来。由于函数的递归调用是后进先出的，所以要用栈来保存这些值。例如，f(3)
的执行中出现的递归调用一返回过程，如图3-1la所示。递归调用一返回的控制在系统内部通过一个工作栈
实现。为了区别返回到哪一级递归调用，在返回地址进栈的同时将该次调用的参数一起保存。这里每次进
栈需要保存2个值：n的值和返回地址。r1、r2、r3和r4分别为递归的返回地址。图3-11b为与图3-11a相应
的工作栈状态变化过程。

=== 第 58 页 ===
《数据结构导论》学习规划卡
第54页
主函数main中，在调用f(3)前，栈为空，调用f(3)后，系统将n的值3和返回地址r1入栈，在调用f(3)
中又调用f(2)，将n的值2和返回地址r2入栈，在调用f(2)中调用f(1)，将n的值1和返回地址r3入栈，在
执行f(1)中调用f(0)后，将n的值0和返回地址r4入栈，在执行f(0)时不再继续递归，得到f(0)=1，第一次
出栈，按照栈顶的地址返回到函数f(1)中，得到f(1)=1*1=1，第二次出栈，按照栈顶中地址返回到函数f(2)
中，得到f(2)=2*1*1=2，第三次出栈，按照栈顶中地址返回到函数f(3)中，得到f(3)=3*2*1*1=6，第四次出
栈，按照栈顶的地址返回到主函数main中，得到m=6，程序最后输出：3!=6
【考点练习】
【真题·单选】栈可以实现（）。

=== 第 59 页 ===
第三章栈、队列和数组
第55页A.函数的嵌套调用和操作系统中进程调度B.函数的嵌套调用和程序递归的处理
C.程序递归的处理和操作系统中进程调度D.操作系统中进程调度和网络管理中的打印服务
【答案】B
【解析】栈是一种后进先出（LIFO，LastInFirstOut）的数据结构，它在实现函数的嵌套调用和程序递归的
处理中起着至关重要的作用。
【真题·填空】栈初始化时，生成一个结点，将该结点的next域设置为______。
【答案】NULL
【真题·应用】设有编号为1，2，3，4的四辆列车，顺序进入一个栈式结构的站台，若列车2最先开出，则
列车出站可能的顺序有几种？并写出这四辆列车所有可能的出站顺序。
【答案】若列车2最先开出站；则列车出站可能的顺序有5种。列车可能的出站顺序有；2134、2143、2314、
2341、2431。
第二节队列
►知识体系
知识点1队列的基本概念【单选、填空】★
队列（Queue）是有限个同类型数据元素的线性序列，是一种先进先出（FirstInFirstOut）的线性表，
新加入的数据元素插在队列尾端，出队列的数据元素在队列首部被删除。图3-12所示为队列示意图，a1是
队列的首元素，an是队列的尾元素。

=== 第 60 页 ===
《数据结构导论》学习规划卡
第56页
排队的规则是不允许“插队”，新加入的成员只能排在队列尾，而且队列中全体成员只能按入队列的
顺序离开队列（即先进先出）。
【例3-6】在操作系统中，为了保持多个进程P1、P2、P3和P4按某种次序依次执行，需要一个队列来
实现这个过程，如图3-13所示。
队列的基本运算：
（1）队列初始化InitQueue(Q)：设置一个空队列Q；
（2）判队列空EmptyQueue(Q)：若队列Q为空，则返回值为1，否则返回值为0；
（3）入队列EnQueue(Q，x)：将数据元素x从队尾一端插入队列，使其成为队列的新尾元素；
（4）出队列OutQueue(Q)：删除队列首元素；
（5）取队列首元素GetHead(Q)：返回队列首元素的值。
知识点2队列的顺序实现【单选、填空、算法设计】★★★
（1）顺序队列
顺序存储实现的队列称为顺序队列，它由一个一维数组（用于存储队列中元素）及两个分别指示队列
首和队列尾元素的变量组成，这两个变量分别称为“队列首指针”和“队列尾指针”。
用类C语言定义顺序队列类型如下：


=== 第 61 页 ===
第三章栈、队列和数组
第57页顺序队列结构类型中有三个域：data、front和rear。其中data为一维数组，存储队列中数据元素。front
和rear定义为整型变量，实际取值范围是0～(maxsize-1)。为了方便操作，规定front指向队列首元素的前
一个单元，rear指向实际的队列尾元素单元，顺序队列存储结构如图3-14所示。
入队列操作可用两条赋值语句：SQ.rear=SQ.rear+1；SQ.data[SQ.rear]=x完成。出队列操作可用一条赋
值语句SQ.front=SQ.front+1完成。但是实际上，用这种方法来实现队列的操作会出现一些问题。图3-15表
示顺序队列入队列、出队列的操作。
图3-15a为空队列，SQ.rear为0，SQ.front为0。
图3-15b为20入队列后，SQ.rear为1，SQ.front为0。
图3-15c为30，40，50依次入队列后，SQ.rear为4，SQ.front为0。
图3-15d为20，30，40，50依次出队列后，SQ.rear为4，SQ.front为4。
图3-15e为60入队列后，SQ.rear为5，SQ.front为4。
在图3-15e的状态下，由于数组的最大下标为5，元素60已占用了该单元，如果还有元素要入队列，
则SQ.rear=SQ.rear+1，SQ.rear将超出数组的下标范围，从而使将要入队的新元素无法进入队列，而此时，
数组中下标低端还有空位置（1到4单元为空），即数组的实际空间并没有占满，这种现象称为“假溢出”。
（2）循环队列
若要插入新元素，应将队列中现有元素向队首方向移动，以便在队尾腾出空间。为了避免元素的移动，
可以将存储队列元素的一维数组首尾相接，形成一个环状，如图3-16所示，这样的队列称为循环队列。

=== 第 62 页 ===
《数据结构导论》学习规划卡
第58页当SQ.rear=maxsize-1时，只要数组的低下标端有空闲空间，仍可进行入队列运算。此时只需令SQ.rear=0，
即把SQ.data[0]作为新的队列尾，并将入队的元素置入此单元中。这样就解决了“假溢出”问题。图中阴影
部分为当前队列已占用的空间，其余为空闲空间。
根据上述想法，循环队列的入队列操作语句应为：
出队列操作对应的赋值语句为：
用类C语言定义循环队列如下：
将上述定义存放到头文件Sequeue.h中。
循环队列克服了假上溢，当队列首结点或队列尾结点在maxsize-1处时，如果再进行入队列或出队列操
作，front和rear值为0，这样形成循环。如果按照上述约定，当队列为空时，有front==rear，队列为满时，
亦有front==rear，因而无法区分这两种情况。对此，有两种解决方法，一是为队列另设一个标志，用来区
分队列是空还是满；二是队列少用一个元素空间，当只剩下一个单元时就认为队列满，此时，队列尾指针
只差一步将追上队列首指针。本书采用第二种解决方法。
循环队列满、队列空状态如图3-17所示，其中阴影部分为已占用的空间。
队列满条件为：
((CQ.rear+1)%maxsize==CQ.front)成立
队列空条件为：

=== 第 63 页 ===
第三章栈、队列和数组
第59页(CQ.rear==CQ.front)成立
循环队列的基本运算如下：
①队列的初始化
②判队列空
③入队列
④出队列

=== 第 64 页 ===
《数据结构导论》学习规划卡
第60页
⑤取队列首元素
图3-18说明循环队列的操作，与图3-15顺序队列状态相对应。
图3-18a循环队列为空队列，CQ.rear为0，CQ.front为0。
图3-18b为20入队列。执行赋值语句CQ.rear=(CQ.rear+1)%maxsize，这时，(CQ.front==0)成立，(CQ.rear=
=1)成立，CQ.data[CQ.rear]为20。
图3-18c为数据元素30，40，50依次入队列，队列尾指针CQ.rear值为4，队列首指针CQ.front值为0。
图3-18d为数据元素20，30，40，50依次出队后循环队列的状态。队列首指针CQ.front值为4，队列
尾指针CQ.rear值为4。
图3-18e为数据元素60入队列，执行两条赋值语句CQ.rear=(CQ.rear+1)%maxsize，CQ.data[CQ.rear]=60，
队列尾指针CQ.rear值为5，队列首指针CQ.front值为4。
图3-18f为数据元素70入队列，执行赋值语句CQ.rear=(CQ.rear+1)%maxsize，CQ.data[CQ.rear]=70，
CQ.front值仍为4。

=== 第 65 页 ===
第三章栈、队列和数组
第61页
知识点3队列的链接实现【填空】★
（1）链接队列的定义
队列的链接实现实际上是使用一个带有头结点的单链表来表示队列，称为链队列。头指针指向链表的
头结点，单链表的头结点的next域指向队列首结点，尾指针指向队列尾结点，即单链表的最后一个结点，
如图3-19所示。
链接队列用类C语言描述类型定义如下：

=== 第 66 页 ===
《数据结构导论》学习规划卡
第62页
将上述定义存放到Lkqueue.h中。
由于链接实现需要动态申请空间，故链队列在一定范围内不会出现队列满的情况，当(LQ.front==LQ.rear)
成立时，队列中无数据元素，此时队列为空。
（2）链队列的基本运算
①队列的初始化（图3-20）
②判队列空
③入队列

=== 第 67 页 ===
第三章栈、队列和数组
第63页
入队列的具体过程如图3-21所示。入队列时，新结点总是增加到队列尾，通过函数malloc申请空间，
将该空间的地址赋值到指针变量temp中，即temp指向该空间，再将x的值填入到该空间的数据域中，将
temp赋值到LQ->rear的next域，以使新结点链入队列尾，成为队列新的尾结点，最后将temp赋值给LQ->rear，
让LQ->rear指向新的尾结点。
④出队列


=== 第 68 页 ===
《数据结构导论》学习规划卡
第64页
出队列的具体过程如图3-22所示。LQ->front指向队列的头结点，出队列时，总是删除LQ->front的直
接后继结点，当队列非空时，将LQ->front的直接后继结点的地址赋值给temp变量，即将temp指向待出队
列的结点，如图3-22a所示，再将temp的直接后继结点的地址赋值给(LQ->front)->next，即(LQ->front)->next
指向队列新的首结点，如图3-22b所示。通过函数free(temp)释放temp空间。如果在出队列前，队列中只有
一个元素，出队列后，队列为空，这时需要让LQ->rear和LQ->front都指向队列头结点。
⑤取队列首元素


=== 第 69 页 ===
第三章栈、队列和数组
第65页知识点4队列应用
【例3-7】在日常生活中，到银行办理业务时，往往需要排队等候，也就是按照“先到先服务”的原则
（这里不考虑不同业务分类处理的情况）。
在排队等候的过程中，主要有两件事：
（1）客户到达银行时，在电脑上取号；
（2）客户等待银行电脑语音报号，当报出某客户的序号时，客户到相应的窗口接受服务。
现在用计算机来模拟等待和接收服务这一过程。显然，客户等待服务，可以用队列这一数据结构来实
现。“在电脑上取号”用命令'A'表示，“客户到相应的窗口接受服务”用命令'N'表示，命令'Q'表示不再接
受取号，已排队等候的人依次接受服务，然后结束模拟。
算法描述如下：
while(1)
{接受命令;
若为'A',取号,排队等待;
若为'N',队列中第一个人,即持所报号的人,出队列接受服务;
若为'Q',队列中剩余人按顺序依次接受服务,结束。
}
队列采用链队，DataType为int。链队结构用类C语言算法描述如下：
用类C语言算法描述如下：

=== 第 70 页 ===
《数据结构导论》学习规划卡
第66页
实际上，在银行办理业务，会涉及多种业务。例如，个人人民币业务，个人外汇业务，机构人民币业
务，机构外汇业务等。银行叫号系统一般根据业务范围设立多个队列。
【考点练习】
【真题·单选】带头结点链队列的头指针和尾指针分别为front和rearn，则判断队列空的条件为（）。
A.front==rear B.front!=NULL

=== 第 71 页 ===
第三章栈、队列和数组
第67页C.rear!=NULL D.front==NULL
【答案】A
【解析】队列空条件为：(CQ.rear==CQ.front)成立
【真题·填空】链队列中，单链表的头结点的next域指向队列______结点。
【答案】首
【真题·填空】顺序队列需要预先定义队列的容量，一般将数组的首尾相接，形成循环队列，这样可以解决
“______”问题。
【答案】假溢出
第三节数组
►知识体系
知识点1数组的逻辑结构和基本运算【填空】
数组可以看成线性表的一种推广。一维数组又称向量，它由一组具有相同类型的数据元素组成，并存
储在一组连续的存储单元中。若一维数组中的数据元素又是一维数组结构，则称为二维数组；依此类推，
若一维数组中的元素又是一个二维数组结构，则称作三维数组。一般地，一个n维数组可以看成元素为n-1
维数组的线性表。
以二维数组为例，说明数组的逻辑结构。图3-23为二维数组a[m][n]。

=== 第 72 页 ===
《数据结构导论》学习规划卡
第68页
对于图3-23所示的二维数组，它可看成是由m个行向量或者n个列向量组成的线性表。
二维数组看成是n个列向量组成的线性表，它可以表示成：
a'=(α0，α1，…，αn-1)
每个元素αi本身也是一个线性表αi=(a0i，a1i，…，am-1i)0≤i≤n-1。具体形式如图3-24所示。
二维数组看成是m个行向量组成的线性表，它可以表示成：
a"=(β0，β1，…，βm-1)
每个元素βj本身也是一个线性表βj=(aj0，aj1，…ajn-1)0≤j≤m-1，具体形式如图3-25所示。
数组通常只有两种基本运算：
（1）读：给定一组下标，返回该位置的元素内容；
（2）写：给定一组下标，修改该位置的元素内容。
知识点2数组的存储结构【单选】★
一维数组元素的内存单元地址是连续的，二维数组可有两种存储方法：一种是以列序为主序的存储；
另一种是以行序为主序的存储。在类C语言的编译程序中，数组采用的是以行序为主序的存储方法，某些
语言的编译程序，数组采用以列序为主序的存储方法。图3-26给出了两种存储方法的示意图。

=== 第 73 页 ===
第三章栈、队列和数组
第69页
对于二维数组a[m][n]，如果每个元素占k个存储单元，以行为主序为例，讨论数组元素a[i][j]位置与下
标的关系。
由于下标从0开始，元素a[i][j]之前已经有i行元素，每行有n个元素，在第i行，有j+1个元素，总
共有n*i+j+1个元素，第一个元素与a[i][j]相差n*i+j+1-1个位置，故a[i][j]的位置为：loc[i，j]=loc[0，0]+
(n*i+j)*k。
由上述公式可知，数组元素的存储位置是下标的线性函数。
知识点3矩阵的压缩存储【单选、填空、应用】★★★
矩阵是很多科学计算问题研究的对象，矩阵可以用二维数组来表示。在数值分析中经常出现一些高阶
矩阵，这些高阶矩阵中有许多值相同的元素或零元素，为了节省存储空间，对这类矩阵采用多个值相同的
元素只分配一个存储空间，零元素不存储的策略，这一方法称为矩阵的压缩存储。
如果值相同的元素或者零元素在矩阵中的分布有一定规律，称此类矩阵为特殊矩阵。矩阵的非零元素
个数很少的矩阵称为稀疏矩阵。
（1）特殊矩阵
①对称矩阵

=== 第 74 页 ===
《数据结构导论》学习规划卡
第70页若一个n阶方阵A中的元素满足下述条件：
aij=aji 0≤i，j≤n-1
则A称为对称矩阵。
对称矩阵有近一半的元素可以通过其对称元素获得，为每一对对称元素只分配一个存储单元，则可将
n²个元素压缩存储到含有n(n+1)/2个元素的一维数组中。我们以行为主序存储其下三角（包括对角线）中的
元素，如图3-27所示。
假设以一维数组M[n(n+1)/2]作为n阶对称矩阵A的存储结构，存储情况如图3-28所示。
设矩阵元素aij在数组M中的位置为k，(i，j)和k存在如下对应关系：
对于任意的给定的一组下标(i，j)均可在M中找到矩阵元素aij。反之，对所有的k=0，1，…，n(n+1)/2-1，
都能确定M[k]中该元素在矩阵中的位置(i，j)即M[k]和aij间存在着一一对应关系。
②三角矩阵
以主对角线为界的上（下）半部分是一个固定的值c或零，这样的矩阵叫做下（上）三角矩阵，如图
3-29所示。

=== 第 75 页 ===
第三章栈、队列和数组
第71页
为存储三角矩阵，采用数组M[n(n+1)/2]，把矩阵中上（下）三角部分的n(n+1)/2个元素存储在数组
M[0]～M[n(n+1)/2-1]的n(n+1)/2个单元中，其中c若非0，则存放到数组的M[n(n+1)/2]中。
上三角矩阵中，第i行除常数外有n-i个元素，第0行有n个元素，而aij之前已经有i行。前i行的元
素个数总共有
在第i行上，aij是该行的第j－i＋1个元素，M[k]和aij的对应关系是：
下三角矩阵的存储和对称矩阵类似。M[k]和aij的对应关系是：
（2）稀疏矩阵
假设m行n列的矩阵有t个非零元素，当t<<m*n时，则称矩阵为稀疏矩阵。图3-30给出了一个稀疏
矩阵示例。


=== 第 76 页 ===
《数据结构导论》学习规划卡
第72页下面介绍稀疏矩阵压缩存储的三元组表示法。矩阵中的每个元素都是由行序号和列序号唯一确定的。
需要用三个项来表示稀疏矩阵中的非零元素aij，即(i，j，aij)，其中i表示行序号，j表示列序号，aij是非零
元素的值，通常称为三元组。将稀疏矩阵中的所有非零元素用这种三元组的形式表示，并按照一定的次序
组织在一起，就形成了三元组表示法。
三元组的结点如图3-31所示。
图3-31中，v为非零元素，i为非零元素v所在矩阵的行号，j为v所在矩阵的列号。
图3-30中的稀疏矩阵A可表示成如下的三元组表。
((0，1，5)，(2，1，－1)，(2，3，7)，(3，1，6)，(4，4，9))
三元组表的类型说明如下：
【考点练习】
【真题·填空】对称矩阵有近一半元素可以通过其对称元素获得,因此可将含有n²个元素的对称矩阵压缩存储
到含有______个元素的一维数组中。
【答案】n(n+1)/2
【真题·填空】稀疏矩阵可以采用______表示法进行压缩存储。
【答案】三元组

=== 第 77 页 ===
第三章栈、队列和数组
第73页第四节应用举例
►知识体系
知识点1案例
用模拟停车场管理来说明栈和队列两种数据结构的综合应用。
【案例】设停车场（图3-32）内只有一个可停放几辆汽车的狭长通道，且只有一个大门可供汽车进出。
汽车在停车场内按车辆到达时的先后顺序，依次由北向南排列（大门在最南端，最先到达的第一辆车停放
在车场的最北端），若车场内已停满汽车，则后来的汽车只能在门外的便道上等候，一旦停车场内有车开
走，则排在便道上的第一辆车即可开入；当停车场内某辆车要离开时，由于停车场是狭长的通道，在它之
后开入车场的车辆必须先开出去为它让路，待该辆车开出大门外后，为它让路的车辆再按原次序进入停车
场。在这里假设汽车不能从便道上开走。试设计这样一个停车场管理程序（这里只是一个假想的停车场管理）。
【分析】汽车在停车场内进出方式和栈的特征相似。当有空位时，汽车进入停车场；停车场的汽车离
开停车场时，车场内其他汽车为该辆汽车让路，是按栈的方式进行；汽车在便道上等候是按队列的方式进
行。因此，将停车场设计成一个栈，汽车让路也需要另一个栈来协助完成，汽车进出便道用队列来实现。
本程序中，栈采用顺序存储结构，队列用链式存储结构，分别在头文件Seqstack.h和Lkqueue.h中定义。


=== 第 78 页 ===
《数据结构导论》学习规划卡
第74页


=== 第 79 页 ===
第三章栈、队列和数组
第75页


=== 第 80 页 ===
《数据结构导论》学习规划卡
第76页
知识点2命令含义规定
命令'A'表示车辆进入停车场，命令'D'表示车辆开出停车场，当车号为0时，不管读入何命令，程序结束。
停车场管理的算法描述如下：
（1）接受命令和车号，当车号为0时，程序结束，否则执行（2）；
（2）若命令为'A'，汽车要进停车场，先判断停车场栈是否满，若不满，则汽车进栈，否则汽车入便道
队列等候；
（3）若命令为'D'，汽车要离开停车场，为给该汽车让路，将停车场栈上若干辆汽车入临时栈，等这辆
车出停车场后，临时栈中汽车出栈，再回到（进）停车场栈，然后看便道队列是否为空，若不空则说明有
汽车等候，从队首取出汽车号，让该车进停车场栈；
（4）重复（1）～（3）。
下面是解决问题的应用程序。


=== 第 81 页 ===
第三章栈、队列和数组
第77页


=== 第 82 页 ===
《数据结构导论》学习规划卡
第78页第四章树和二叉树
►知识体系


=== 第 83 页 ===
第四章树和二叉树
第79页►考点透析
知识点 考核要求 考试题型 重点星级
树的概念 识记 单选、填空 ★
树的相关术语 识记 单选、填空 ★★
二叉树的基本概念 识记 单选、填空、应用 ★★
二叉树的性质 领会 单选、填空 ★★
二叉树的顺序存储结构 领会 填空 ★
二叉树的链式存储结构 领会
二叉树遍历的递归实现 综合应用 单选、应用、算法设计 ★★★
二叉树的层次遍历 领会 单选
二叉树遍历的非递归实现 领会
应用举例 简单应用 填空、应用 ★★
树的存储结构 领会
树、森林与二叉树的关系 领会 填空、应用 ★★
树和森林的遍历 识记
分类与判定 领会 填空
哈夫曼（Huffman）树与哈夫曼算法 领会 单选 ★
哈夫曼编码 简单应用 应用 ★

=== 第 84 页 ===
《数据结构导论》学习规划卡
第80页第一节树的基本概念
►知识体系
线性结构中的一个结点至多只有一个直接后继，而树形结构中一个结点可以有一个或多个直接后继。
因此，树形结构可以表示更复杂的数据。例如，可以用图4-1所示的树形结构描述老虎家族关系。
图4-1看上去均像一棵倒挂的树，在图4-1a中树根是老虎，它有两个孩子分别是大虎和二虎，大虎有
一个孩子小虎一，二虎有两个孩子分别是小虎二和小虎三。
上例容易看出整个树可以分解成两个部分：①大虎（图4-1c）；②二虎（图4-1b）。而对大虎和二虎
同样可以按上述方法进行分解。容易看出，由这种分解而得到的关系仍保持树形结构。
知识点1树的概念【单选、填空】★
树（Tree）是一类重要的数据结构，其定义如下：
树是n（n≥0）个结点的有限集合，一棵树满足以下两个条件：
（1）当n=0时，称为空树；
（2）当n>0时，有且仅有一个称为根的结点，除根结点外，其余结点分为m（m≥0）个互不相交的非
空集合T1，T2，…，Tm，这些集合中的每一个都是一棵树，称为根的子树。

=== 第 85 页 ===
第四章树和二叉树
第81页n=1的树是由只含一个结点的集合构成的，这种集合满足定义的条件。首先，它有根，即该集合所含的
唯一结点。其次，除根外的其余结点（零个）分成m=0个不相交的非空集合，因此条件也成立。这就是说，
任何只含一个结点的集合是一棵树。所以结点小虎一是一棵树，结点小虎二和小虎三各自也是一棵树。当
n>1时，要判断n个结点的集合是不是一棵树，必须检验它是否同时满足定义中的条件。值得注意的是条件
(2)，该条件的关键在于判断各个非空集合Ti(i=1，…，m)是不是树。上述树形结构的定义是递归的。
为了判定图4-1a所示结构是一棵树，首先必须判定：①图4-1b所示结构是树；②图4-1c所示结构是树。
对①，按定义继续分解为两个子集{小虎二}和{小虎三}。由于单个结点是树，由定义可知图4-1b所示结构
是树。类似地，可判定图4-1c所示结构是树。因此，图4-la所示结构是一棵树。
图4-2所示的几种结构都不是树，因为它们都不满足定义的条件。图4-2a有2个结点A和B，A不是
B的子树，B也不是A的子树，图4-2b无法分成0个或多个不相交的非空集合，图4-2c中有2个根。
森林（Forest）是m（m≥0）棵互不相交的树的集合。树的每个结点的子树是森林。删除一个非空树的
根结点，它的子树便构成森林。
图4-2a是一个森林，图4-2c也是一个森林。
知识点2树的相关术语【单选、填空】★★
（1）相关术语
①结点的度：树上任一结点所拥有的子树的数目称为该结点的度。例如，图4-la中结点老虎的度为2，
大虎的度为1，小虎一的度为0。
②叶子：度为0的结点称为叶子或终端结点。
③树的度：一棵树中所有结点的度的最大值称为该树的度。
一个结点的子树的根称为该结点的孩子（或称子结点）。相应地该结点称为孩子的双亲（也称父结点）。
例如，图4-la中结点大虎是结点老虎的孩子，也是老虎的一棵子树的根结点。父结点相同的结点互称为兄
弟。一棵树上除根结点以外的任何其他结点称为根的子孙。反之，若B是A的子孙，则称A是B的祖先。
例如，老虎和大虎是小虎一的祖先，但大虎和小虎三、小虎一都不是小虎二的祖先。
④结点的层次：从根开始算起，根的层次为1，其余结点的层次为其双亲的层次加1。

=== 第 86 页 ===
《数据结构导论》学习规划卡
第82页⑤树的高度：一棵树中所有结点层次数的最大值称为该树的高度或深度。
⑥有序树：若树中各结点的子树从左到右是有次序的，不能互换，称为有序树。有序树中最左边子树
的根称为第1个孩子，左边第i个子树的根称为第i个孩子。
⑦无序树：若树中各结点的子树是无次序的，可以互换，则称为无序树。
（2）树的基本运算包括
①求根Root(T)：求树T的根结点；
②求双亲Parent(T，X)：求结点X在树T上的双亲结点；若X是树T的根或X不在T上，则结果为
一特殊标志；
③求孩子Child(T，X，i)：求树T上结点X的第i个孩子结点；若X不在T上或X没有第i个孩子，
则结果为一特殊标志；
④建树Create(X，T1，…，Tk)，k>1：建立一棵以X为根，以T1，…，Tk为第1，…，k棵子树的树；
⑤剪枝Delete(T，X，i)：删除树T上结点X的第i棵子树；若T无第i棵子树，则为空操作；
⑥遍历TraverseTree(T)：遍历树，即访问树中每个结点，且每个结点仅被访问一次。
【考点练习】
【真题·单选】叶子的度为（）。
A.-1 B.0
C.1 D.2
【答案】B
【解析】叶子：度为0的结点称为叶子或终端结点。
【真题·填空】一棵树中所有结点的度的______称为该树的度。
【答案】最大值

=== 第 87 页 ===
第四章树和二叉树
第83页第二节二叉树
►知识体系
知识点1二叉树的基本概念【单选、填空、应用】★★
（1）概念
二叉树（BinaryTree）是n（n≥0）个元素的有限集合，该集合或者为空，或者由一个根及两棵互不相
交的左子树和右子树组成，其中左子树和右子树也均为二叉树。
二叉树的任一结点都有两棵子树（它们中的任何一个都可以是空子树），并且这两棵子树之间有次序
关系，即如果互换了位置就成为一棵不同的二叉树。二叉树上任一结点左、右子树的根分别称为该结点的
左孩子和右孩子。除这几个术语之外，树的其他术语也适用于二叉树。
注意，由于二叉树上任一结点的子树有左、右之分，因此即使一结点只有一棵非空子树，仍须区别它
是该结点的左子树还是右子树，这是与树不同的。图4-3a、b、c分别是含两个结点A、B且以A为根的二
叉树和树的示意图。
二叉树有五种基本形态，如图4-4所示，其中方块表示子树。

=== 第 88 页 ===
《数据结构导论》学习规划卡
第84页
（2）二叉树的基本运算
①初始化Initiate(BT)：建立一棵空二叉树，BT=
。
②求双亲Parent(BT，X)：求出二叉树BT上结点X的双亲结点，若X是BT的根或X根本不是BT上
的结点，运算结果为NULL。
③求左孩子Lchild(BT，X)和求右孩子Rchild(BT，X)：分别求出二叉树BT上结点X的左、右孩子；
若X为BT的叶子或X不在BT上，运算结果为NULL。
④建二叉树Create(BT)：建立一棵二叉树BT。
⑤先序遍历PreOrder(BT)：按先序对二叉树BT进行遍历，每个结点被访问一次且仅被访问一次，若
BT为空，则运算为空操作。
⑥中序遍历InOrder(BT)：按中序对二叉树BT进行遍历，每个结点被访问一次且仅被访问一次，若BT
为空，则运算为空操作。
⑦后序遍历PostOrder(BT)：按后序对二叉树BT进行遍历，每个结点被访问一次且仅被访问一次，若
BT为空，则运算为空操作。
⑧层次遍历LevelOrder(BT)：按层从上往下，同一层中结点按从左往右的顺序，对二叉树进行遍历，每
个结点被访问一次且仅被访问一次，若BT为空，则运算为空操作。
知识点2二叉树的性质【单选、填空】★★
性质1：二叉树第i（i≥1）层上至多有2i－1个结点。
性质2：深度为k（k≥1）的二叉树至多有2k－1个结点。
性质3：对任何一棵二叉树，若度数为0的结点（叶结点）个数为n0，度数为2的结点个数为n2，则
n0=n2+1。
满二叉树：深度为k（k≥1）且有2k-1个结点的二叉树称为满二叉树。由性质2知，满二叉树上的结点
数已达到了二叉树可以容纳的最大值。图4-5a为一棵深度为3的满二叉树。

=== 第 89 页 ===
第四章树和二叉树
第85页
完全二叉树：如果对满二叉树按从上到下，从左到右的顺序编号，并在最下一层删去部分结点（删后
最后一层仍有结点），如果删除的这些结点的编号是连续的且删除的结点中含有最大编号的结点，那么这
棵二叉树就是完全二叉树。
图4-5c、d所示的二叉树不是完全二叉树。由定义知，满二叉树一定是完全二叉树，完全二叉树不一定
是满二叉树。
完全二叉树还有下述两个重要性质（其中
表示不大于x的最大整数）：
性质4：含有n个结点的完全二叉树的深度为[log₂n]+1。
性质5：如果将一棵有n个结点的完全二叉树按层编号，按层编号是指：将一棵二叉树中的所有n个结
点按从第一层到最大层，每层从左到右的顺序依次标记为1，2，…，n。则对任一编号为i（1≤i≤n）的结
点A有：
（1）若i=1，则结点A是根；若i>1，则A的双亲Parent(A)的编号为
；
（2）若2*i>n，则结点A既无左孩子，也无右孩子；否则A的左孩子Lchild(X)的编号为2*i；
（3）若2*i+1>n，则结点A无右孩子；否则，A的右孩子Rchild(A)的编号为2*i十1。
读者可以从图4-5a、b所示的二叉树为例验证此性质，但对非完全二叉树该性质不成立。此性质在一般

=== 第 90 页 ===
《数据结构导论》学习规划卡
第86页情况下的直观图示如图4-6所示。性质5表明完全二叉树上结点之间的父子关系可由它们编号之间的关系来
表达。这一性质是二叉树顺序存储结构的基础。
【考点练习】
【真题·单选】对任何一棵二叉树，若度数为0的结点（叶结点）个数为n0，度数为2的结点个数为n2，则
n0等于（）。
A.0 B.n2-1
C.n2 D.n2+1
【答案】D
【解析】对任何一棵二叉树，若度数为0的结点（叶结点）个数为n0，度数为2的结点个数为n2，则n0=n2+1。
【真题·填空】满二叉树一定是______二叉树。
【答案】完全

=== 第 91 页 ===
第四章树和二叉树
第87页第三节二叉树的存储结构
►知识体系
二叉树通常有两类存储结构：顺序存储结构和链式存储结构。链式存储结构在插入删除结点时较方便，
在某些情况下，二叉树的顺序存储结构也很有用。
知识点1二叉树的顺序存储结构【填空】★
二叉树的顺序存储结构可以用一维数组来实现，二叉树上的结点按某种次序分别存入该数组的各个单元中。
由二叉树的性质5可知，如果对任一完全二叉树上的所有结点按层编号，则结点编号之间的关系可以
准确地反映结点之间的逻辑关系。因此，对于任何完全二叉树来说，可以采用以编号作为数组的下标的方
法将结点存入一维数组中，也就是将编号为i的结点存入一维数组的以i为下标的数组元素中。例如，图4-7a
所示的完全二叉树可按上述策略存入数组Btree[11]中，这里，为方便起见，将Btree[0]空着，如图4-7b所
示。图4-7a中结点旁边的数字为结点的编号。


=== 第 92 页 ===
《数据结构导论》学习规划卡
第88页在这一存储结构中，由于结点的存储位置（即下标）也就是它的编号，因此结点间的逻辑关系可通过
它们下标间的数值关系确定。例如，若要在图4-7a所示的二叉树中找结点C的左孩子，根据二叉树性质5，
从C的下标值4可算出其左孩子的下标值为8，因此C的左孩子是D。假如要找结点F的右孩子，由F的
下标值为5及2×5+1=11>10知F没有右孩子。所以，在这一存储结构上，借助二叉树性质5，可以比较方
便地实现二叉树的某些基本运算。
由于上述性质5对非完全二叉树不成立（图4-5c、d）。因此，如果需要顺序存储的非完全二叉树，首
先必须用某种方法将其转化为完全二叉树，为此可增设若干个虚拟结点。图4-8a所示为一棵非完全二叉树，
若直接对其结点按层编号，然后再将各结点按编号存入数组，所得结果如图4-8c所示。这种方法不能根据
结点间的下标关系确定它们之间的逻辑关系。
例如，结点E的下标值为5，但其左孩子F的下标值并不是10。因此，这种方法不便于实现二叉树求
孩子等基本运算。通过在图4-8a所示二叉树上增加一些虚拟结点（阴影表示）的方法可将其转化成一棵完
全二叉树，例图4-8b所示。对处理后得到的完全二叉树重新按层编号，然后再按编号将各结点存入数组。
各个虚拟结点在数组中用一个特殊记号∧表示，如图4-8d所示。这样可以用与处理完全二叉树相同的方法
实现二叉树的基本运算。但这种方法的缺点是造成了空间的浪费。


=== 第 93 页 ===
第四章树和二叉树
第89页知识点2二叉树的链式存储结构
二叉树有不同的链式存储结构，其中最常用的是二叉链表与三叉链表。二叉链表和三叉链表的结点形
式如图4-9a、b所示。
在二叉链表中，data域用于存储二叉树结点中的数据信息；lchild是指向左孩子的指针（左指针）。类

=== 第 94 页 ===
《数据结构导论》学习规划卡
第90页似地，rchild是指向右孩子的指针（右指针）。此外，每个二叉链表还必须有一个指向根结点的指针，该指
针称为根指针。与链表头指针类似，根指针具有标识二叉链表的作用，对二叉链表的访问只能从根指针开
始。图4-10a、b分别表示一棵二叉树及其相应的二叉链表。如果某个结点的左孩子或右孩子不存在时，则
相应指针域值为空（NULL）。由此可知叶结点的左右指针必为空（NULL）。在三叉链表中每个结点增加
一个指针域parent，用于指向该结点的双亲。
二叉链表的类型定义如下：
将上述定义存放到头文件Tree.h。
BinTreeroot;///root为指向根结点的指针，BinTree为指向二叉链表结点的指针类型。
若二叉树为空，则root=NULL。若某结点的某个孩子不存在，则相应的指针为空。具有n个结点的二
叉树中，有2n个指针域，其中只有n-1个用来指向结点的左、右孩子，其余的n+1个指针域为NULL。
三叉链表是二叉树的另一种主要的链式存储结构。图4-10c所示为图4-10a所示二叉树的三叉链表存储
表示，三叉链表的类型定义如下：
二叉树的链式存储结构操作方便，结点间的父子关系在二叉链表和三叉链表中被直接表达成对应存储
结点之间的指针，因而成为二叉树最常用的存储结构。
【考点练习】
【真题·填空】二叉树的顺序存储结构可以用______维数组来实现。
【答案】一
【真题·填空】对于任何完全二叉树来说，可以采用以______作为数组的下标的方法将结点存入一维数组中。
【答案】编号

=== 第 95 页 ===
第四章树和二叉树
第91页第四节二叉树的遍历
►知识体系
知识点1二叉树遍历的递归实现【单选、应用、算法设计】★★★
二叉树的遍历是指按某种次序访问二叉树上的所有结点，使每个结点被访问一次且仅被访问一次。由
二叉树的定义可知，一棵二叉树由三部分组成：根、根的左子树和根的右子树。因此对二叉树的遍历只要
按某种次序执行下列三步，就可以遍历整个二叉树。
①访问根结点；
②遍历根的左子树（即依次访问左子树上的全部结点）；
③遍历根的右子树（即依次访问右子树上的全部结点）。
因为左、右子树都是二叉树（可以是空二叉树），对它们的遍历可以按上述方法继续分解，直到每棵
子树均为空二叉树为止，由此可见，若以D、L、R分别表示访问根结点、遍历根结点的左子树和遍历根结
点的右子树，则共有六种可能的次序：DLR、LDR、LRD、DRL、RDL和RLD。如果限定先左后右，即只
考虑DLR、LDR和LRD，这三种次序分别称为先序遍历、中序遍历和后序遍历。
（1）先序遍历
若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：
①访问根结点；
②先序遍历左子树；
③先序遍历右子树。
（2）中序遍历
若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：
①中序遍历左子树；
②访问根结点；

=== 第 96 页 ===
《数据结构导论》学习规划卡
第92页③中序遍历右子树。
（3）后序遍历
若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：
①后序遍历左子树；
②后序遍历右子树；
③访问根结点。
上面给出的先序、中序和后序遍历的定义都是递归的，因而根据定义很容易得到相应遍历的递归算法。
假定visit(bt)是一个已定义的过程，其功能是访问指针bt所指结点。在二叉链表上实现三种遍历的递归算法
描述如下：
上述三种遍历算法均可实现访问一棵二叉树中每个结点的访问，且每个结点仅被访问一次，由于访问
根结点的操作visit(bt)在算法中的位置不同，因此访问根结点的顺序不同，最后得到的结点访问序列也不同。
【例4-1】分别给出图4-11a的二叉树先序遍历、中序遍历、后序遍历三种访问方式的结点访问序列。

=== 第 97 页 ===
第四章树和二叉树
第93页
【分析】将图4-11a的二叉树划分成3个部分：根A、A的左子树、A的右子树，如图4-11b所示。
（1）分析先序遍历过程，根据preorder算法，对3个部分进行访问过程如下：
1访问A （第1个被访问的结点）
2先序遍历A的左子树(BDEG)
2.1访问B （第2个被访问的结点）
2.2先序遍历B的左子树(D)
2.2.1访问D （第3个被访问的结点）
2.2.2先序遍历D的左子树(空)
2.2.3先序遍历D的右子树(空)
2.3先序遍历B的右子树(EG)
2.3.1访问E （第4个被访问的结点）
2.3.2先序遍历E的左子树(G)
2.3.2.1访问G （第5个被访问的结点）
2.3.2.2先序遍历G的左子树(空)
2.3.2.3先序遍历G的右子树(空)
2.3.3先序遍历E的右子树(空)
3先序遍历A的右子树(CF)
3.1访问C （第6个被访问的结点）
3.2先序遍历C的左子树(空)
3.3先序遍历C的右子树(F)

=== 第 98 页 ===
《数据结构导论》学习规划卡
第94页3.3.1访问F （第7个被访问的结点）
3.3.2先序遍历F的左子树(空)
3.3.3先序遍历F的右子树(空)
得到先序遍历的结点序列是：ABDEGCF
（2）分析中序遍历过程，根据inorder算法，对3个部分进行访问过程如下：
1中序遍历A的左子树(BDEG)
1.1中序遍历B的左子树(D)
1.1.1中序遍历D的左子树(空)
1.1.2访问D （第1个被访问的结点）
1.1.3中序遍历D的右子树(空)
1.2访问B （第2个被访问的结点）
1.3中序遍历B的右子树(EG)
1.3.1中序遍历E的左子树(G)
1.3.1.1中序遍历G的左子树(空)
1.3.1.2访问G （第3个被访问的结点）
1.3.1.3中序遍历G的右子树(空)
1.3.2访问E （第4个被访问的结点）
1.3.3中序遍历E的右子树(空)
2访问A （第5个被访问的结点）
3中序遍历A的右子树(CF)
3.1中序遍历C的左子树(空)
3.2访问C （第6个被访问的结点）
3.3中序遍历C的右子树(F)
3.3.1中序遍历F的左子树(空)
3.3.2访问F （第7个被访问的结点）
3.3.3中序遍历F的右子树(空)
得到中序遍历的结点序列是：DBGEACF
（3）分析后序遍历过程，根据postorder算法，对3个部分进行访问过程如下：
1后序遍历A的左子树(BDEG)
1.1后序遍历B的左子树(D)
1.1.1后序遍历D的左子树(空)

=== 第 99 页 ===
第四章树和二叉树
第95页1.1.2后序遍历D的右子树(空)
1.1.3访问D （第1个被访问的结点）
1.2后序遍历B的右子树(EG)
1.2.1后序遍历E的左子树(G)
1.2.1.1后序遍历G的左子树(空)
1.2.1.2后序遍历G的右子树(空)
1.2.1.3访问G （第2个被访问的结点）
1.2.2后序遍历E的右子树(空)
1.2.3访问E （第3个被访问的结点）
1.3访问B （第4个被访问的结点）
2后序遍历A的右子树(CF)
2.1后序遍历C的左子树(空)
2.2后序遍历C的右子树(F)
2.2.1后序遍历F的左子树(空)
2.2.2后序遍历F的右子树(空)
2.2.3访问F （第5个被访问的结点）
2.3访问C （第6个被访问的结点）
3访问A （第7个被访问的结点）
得到后序遍历的结点序列是：DGEBFCA
以遍历为基础，可以实现二叉树上的许多运算。这里举例加以说明。
【例4-2】利用二叉树遍历的递归算法，求二叉树的高度。
【分析】算法思想：利用二叉树的遍历算法，通过遍历分别求得根结点的左子树和右子树的高度，比
较左右子树的高度，这棵二叉树的高度为较高一棵子树的高度加1。
算法描述如下：


=== 第 100 页 ===
《数据结构导论》学习规划卡
第96页知识点2二叉树的层次遍历【单选】
二叉树的层次遍历，是指从二叉树的根结点的这一层开始，逐层向下遍历，在每一层上按从左到右的
顺序对结点逐个访问。
例如，对图4-12所示的二叉树按层次遍历所得到的结点序列为A、B、C、D、E、F。从该序列可以看
出，对同一层上的两个结点x和y，若x在y的左边，则x在y先被访问；同样，对下一层上的结点，x的
孩子结点也一定在y的孩子结点之前被访问。因此，层次遍历可以用一个队列来实现。
设立一个队列Q，用于存放结点，以保证二叉树结点按照层次顺序从左往右进入队列。若二叉树bt非
空，首先，将根结点插入队列，然后，从队列中删除一个结点，访问该结点，并将该结点的孩子结点（如
果有的话）插入队列。若此时队列非空，再从队列中删除一个结点，访问该结点，并将它的孩子结点插入
队列。依次重复进行，直至队列为空。
知识点3二叉树遍历的非递归实现
这里以二叉树的先序遍历为例，讨论二叉树遍历的非递归实现方法。由二叉树的先序遍历方法可知，
当遍历到结点p时，有三项工作需完成：

=== 第 101 页 ===
第四章树和二叉树
第97页①访问结点p(visit(p))；
②先序遍历p的左子树(preorder(p->lchild))；
③先序遍历p的右子树(preorder(p->rchild))。
其中①②两项工作可以按顺序完成，为了能在②做完后顺利做③，必须在做②以前先将结点p保存起
来，在做完②以后，取回结点p，再完成③。在这个过程中，不仅仅只需保存和取回一个p结点，实际上，
在做②先序遍历p的左子树(preorder(p->lchild))过程中，有一系列的“p结点”需要保存和取回，可以看出
保存和取回的顺序正好是相反的，即先保存的结点，最后取回，后保存的结点，最先取回，这正符合栈的
特征，因此，二叉树的先序遍历非递归算法可以借助栈来实现。下面讨论借助栈实现二叉树遍历的非递归
过程。
开始时，指针指向根结点（假设二叉树非空），先访问该结点，并将该结点压入栈中，然后将指针指
向该结点的左孩子，再判断这时的指针是否为空。如果这时指针不为空，那么访问该结点并将该结点压入
栈中，将指针指向它的左孩子，再对这时的指针作同样的判断和操作。如果判断出某结点的左孩子为空，
那么将栈顶结点出栈，并将指针指向它的右孩子，对右孩子做同样的判断和操作（如果右孩子为空，继续
出栈操作）。算法终止的条件是指针为空并且栈空。
这里栈的元素是结点指针，需要将DataType定义为指针型。
用类C语言实现该算法描述如下：
现以图4-12为例说明该算法。初始时指针p指向A，栈为空。

=== 第 102 页 ===
《数据结构导论》学习规划卡
第98页第一步，访问A，将A压入栈中，指针p指向B。
第二步，访问B，将B压入栈中，指针p指向D。
第三步，访问D，将D压入栈中，指针p指向它的左孩子，这时指针为空。
第四步，由于这时指针为空，弹出栈顶元素D，并将指针p指向D的右孩子。
第五步，由于这时指针仍为空，继续弹出栈顶元素B，并将指针p指向B的右孩子E。
第六步，访问E，并将E压入栈中，指针p指向E的左孩子。
第七步，这时指针为空，弹出栈顶元素E，将指针p指向E的右孩子。
第八步，由于这时的指针仍为空，继续弹出栈顶元素A，将指针p指向A的右孩子C。
第九步，访问C，并将C压入栈中，将指针p指向C的左孩子F。
第十步，访问F，并将F压入栈中，指针p指向F的左孩子，这时指针为空。
第十一步，由于指针p为空，弹出栈顶元素F，将指针p指向F的右孩子，这时指针为空。
第十二步，由于指针为空，弹出栈顶元素C，指针p指向C的右孩子，这时指针为空且栈为空，算法
终止。
该算法的流程图如图4-13所示。


=== 第 103 页 ===
第四章树和二叉树
第99页实现中序遍历的非递归算法，只需将先序遍历的非递归算法中的Visit(p->data)移动到Pop(LS，p)和
p=p->rchild之间即可。
后序遍历与先序遍历和中序遍历不同，在后序遍历过程中，结点在第一次出栈后，还需再次入栈，也
就是说，结点要两次入栈，两次出栈，遍历结点是在结点的第二次出栈时进行。因此，为了区别同一个结
点的两次出栈，设置一个标志flag，可以令flag=1表示第一次出栈，结点不能访问；flag=2表示第二次出栈，
结点可以访问。
知识点4应用举例【填空、应用】★★
由二叉树的遍历可知，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的，下面讨论
如何利用二叉树结点的先序序列和中序序列，确定这棵二叉树。
由先序序列的第一个结点可以确定这棵树的根结点。而在中序序列中该根结点将中序序列分成两个子
序列，其中一个子序列是根结点的左子树的中序序列，另一个是根结点的右子树的中序序列。根据这两个
子序列就可以在先序序列中，划分出根结点的左子树结点的先序序列和右子树结点的先序序列，从这两个
先序序列就可以确定左子树的根和右子树的根，用同样的方法可以确定左子树和右子树的其他所有结点。
下面给出由先序序列和中序列构造二叉树的算法。
假设先序遍历的结点序列是：ABDEGCF，中序遍历的结点序列是：DBGEACF。
可定义：chara[10]={'A'，'B'，'D'，'E'，'G'，'C'，'F'};
charb[10]={'D，'B'，'G'，'E'，'A'，'C'，'F'};

=== 第 104 页 ===
《数据结构导论》学习规划卡
第100页通过函数调用Bt=Create(a，b，0，6，0，6)，可构造出图4-11a所示的二叉树。
同理，由二叉树结点的中序序列和后序序列也可以确定一棵二叉树。
下面举例说明如何由二叉树的中序序列和后序序列构造一棵二叉树。
【例4-3】假设一棵二叉树的中序序列与后序序列分别为：BACDEFGH和BCAEDGHF，建立该二叉树。
【分析】
第一步：可以由后序序列BCAEDGHF确定出这棵二叉树的根结点是F。
由根结点F和中序序列BACDEFGH，可得图4-14a.
↑ ↑
F的左子树F的右子树
第二步：由F的左子树的后序序列BCAED和中序序列BACDE得到图4-14b。
↑ ↑ ↑
根节点D的左子树D的右子树
第三步：由D的左子树的后序序列BCA和中序序列BAC得图4-14c。
↑ ↑↑
根节点A的左子树A的右子树
由F的右子树的后序序列GH和中序序列GH，最后得到图4-14d
↑ ↑
根节点H的左子树


=== 第 105 页 ===
第四章树和二叉树
第101页【考点练习】
【真题·单选】树的遍历有三种，为（）。
A.先序、中序和后序遍历 B.先序、中序和层次遍历
C.先序、后序和层次遍历 D.中序、后序和层次遍历
【答案】A
【解析】先序遍历（也称为前序遍历）、中序遍历和后序遍历，是二叉树遍历的三种基本方式。这三种遍
历方式都是基于访问根节点的顺序来定义的。
【真题·填空】由先序序列的第一个结点可以确定这棵树的______结点。
【答案】根
第五节树和森林
►知识体系
知识点1树的存储结构
树是一种常用的数据结构。它有如下三种常用的存储结构。
（1）孩子链表表示法
孩子链表表示法是树的一种链式存储结构。它的主体是一个数组元素个数和树中结点个数相同的一维
数组。树上的一个结点x以及该结点的所有孩子结点组成一个带头结点的单链表，单链表的头结点含有两
个域：数据域和指针域。其中，数据域用于存储结点x中的数据元素，指针域用于存储指向x第一个孩子
结点的指针。除头结点外，其余所有表结点也含两个域：孩子域（child）和指针域（next），孩子域存储其
中一个孩子的序号，指针域指向其下一个孩子的结点。

=== 第 106 页 ===
《数据结构导论》学习规划卡
第102页图4-15b为图4-15a中树的孩子链表存储结构示意图。树T上所有结点按某种顺序存入表头数组，而各
结点的孩子信息存储在各结点的孩子链表中。显然，由孩子域的值可在表头数组中迅速查出对应的孩子结
点。例如，由结点E的孩子链表中表结点的孩子域值5、6、7可立即从表头数组中查出结点E的孩子是结
点G、F和D。孩子链表表示
法的类型定义如下：
为了便于找到双亲，可在各个头结点中增加一个双亲域以存储双亲在头结点数组中的下标值。这种存
储结构称为带双亲的孩子链表表示法。其类型定义与孩子链表类似，只需将头结点的定义改为：

=== 第 107 页 ===
第四章树和二叉树
第103页
树T的带双亲的孩子链表表示如图4-16所示。
（2）孩子兄弟链表表示法
存储时每个结点除了数据域外，还有指向该结点的第一个孩子和下一个兄弟结点的指针。结点结构如
图4-17所示。
图4-18所示为图4-15a中树T的孩子兄弟链表表示。
孩子兄弟链表表示法类型定义如下：
将上述定义存放到头文件Tree.h。
值得注意的是孩子兄弟链表的结构形式与二叉链表完全相同，但结点中指针的含义不同。二叉链表中
结点的左、右指针分别指向左、右孩子；而孩子兄弟链表中结点的两个指针分别指向孩子和兄弟。

=== 第 108 页 ===
《数据结构导论》学习规划卡
第104页例如，在图4-18中，结点A的孩子指针指向它的孩子结点B，兄弟指针指向它的兄弟结点C。结点F
的孩子域为NULL，因为它没有孩子，兄弟域指针指向它的下一个兄弟结点D。
在孩子兄弟链表表示法中，结点形式统一，结点间的联系比较简洁。同时，在这种存储结构上容易实
现树形结构的大多数运算。
例如，若要访问结点X的第i个孩子，只需先从X的孩子域指针找到它的第一个孩子，然后沿这个孩
子结点的兄弟域指针连续扫描i-1个结点即可。
（3）双亲表示法
双亲表示法由一个一维数组构成。数组的每个分量包含两个域：数据域和双亲域。数据域用于存储树
上一个结点中数据元素，双亲域用于存储本结点的双亲结点在数组中的序号（下标值）。图4-15a中树的双
亲表示法如图4-19所示。


=== 第 109 页 ===
第四章树和二叉树
第105页通过任一结点的双亲域的值，可以找到该结点的双亲。例如，在图4-19中，结点B的双亲域的值为1，
它是其双亲结点A在数组中的序号。这说明结点B的双亲结点为结点A。因为根结点没有双亲，其双亲域
的值置为-1。双亲链表的类型定义如下：
知识点2树、森林与二叉树的关系【填空、应用】★★
（1）树转换成二叉树
任何一棵树可唯一地与一棵二叉树对应。相应地，一棵二叉树也唯一地对应一棵树，即树与二叉树可
以互相转换。
将树转换成二叉树的方法如下：
①将所有兄弟结点连接起来；
②保留第一个兄弟结点与父结点的连接，断开其他兄弟结点与父结点的连接，然后以根结点为轴心按
顺时针的方向旋转45°角。
如图4-20所示，将B、C、D结点连接起来，保留A与B的连接，断开A与C，A与D的连接，最后
按顺时针的方向旋转45°角，C成为结点B的右孩子，D成为结点C的右孩子，E为B的左孩子。
（2）森林转换成二叉树
森林F转换成二叉树的方法如下：
①将每棵树转换成相应的二叉树；
②将①中得到的各棵二叉树的根结点看作是兄弟连接起来。图4-21为森林转换到二叉树的过程。

=== 第 110 页 ===
《数据结构导论》学习规划卡
第106页
（3）二叉树转换成森林
以图4-22a所示的二叉树为例，说明将二叉树转换成对应的森林的方法如下：
①在待转换的二叉树中，断开根结点与右孩子的连线，得到两棵二叉树，其中一棵是以二叉树B的根
结点为根的二叉树，另一棵是以根结点的右孩子E为根结点的二叉树。图4-22a中，断开A与E的连线后
得到两棵如图4-22b所示两棵的二叉树B1和B2。
②在二叉树B1中，连接A与C，A与D。然后将B和C的连线断开，C和D的连线断开。
③重复步骤①②对B2进行转换。
图4-22是按上述步骤将二叉树B转换成对应的森林的过程。

=== 第 111 页 ===
第四章树和二叉树
第107页
知识点3树和森林的遍历
（一）树的遍历
与二叉树类似，这里，我们定义树的先序遍历、后序遍历和层次遍历。

=== 第 112 页 ===
《数据结构导论》学习规划卡
第108页（1）先序遍历。若树非空，则
①访问根结点；
②依次先序遍历根的各棵子树T1，…，Tm。
（2）后序遍历。若树非空，则
①依次后序遍历根的各棵子树T1，…，Tm；
②访问根结点。
（3）层次遍历。
①若树非空，访问根结点；
②若第i（i≥1）层结点已被访问，第i+1层结点尚未访问，则从左到右依次访问第i+1层结点。
显然，对图4-15a所示的树来说，先序遍历得到结点访问序列为H，A，B，E，G，F，D，C；后序遍
历得到结点访问序列为B，G，F，D，E，A，C，H；层次遍历得到结点访问序列为H，A，C，B，E，G，
F，D。
（二）森林的遍历
森林有两种遍历方法：
（1）先序遍历森林。若森林非空，则
①访问森林中第一棵树的根结点；
②先序遍历森林第一棵树的根结点的子树组成的森林；
③先序遍历除去第一棵树之外其余的树组成的森林。
对图4-21a中的森林进行先序遍历，得到的先序序列为ABCDEFGHJI
（2）中序遍历森林。若森林非空，则
①中序遍历森林中第一棵树的根结点的子树组成的森林；
②访问第一棵树的根结点；
③中序遍历除去第一棵树之外其余的树组成的森林。
对图4-21a中的森林进行中序遍历，得到的中序序列为BCDAFEJHIG
图4-2le二叉树是由图4-21a中的森林转换得到的，对该二叉树分别进行先序遍历和中序遍历，可以分
别得到与图4-21a森林的先序序列和中序序列相同的序列。
【考点练习】
【真题·填空】设森林F中有三棵树，第一、第二、第三棵树的结点个数分别为M1、M2和M3。与森林F
对应的二叉树根结点的右子树上的结点个数是______。

=== 第 113 页 ===
第四章树和二叉树
第109页【答案】M2+M3
【真题·应用】将下图所示的森林转换成二叉树。
【答案】
第六节判定树和哈夫曼树
►知识体系
知识点1分类与判定【填空】
树有广泛的应用，其中一种重要的应用是描述分类过程。分类是一种常用运算，其作用是将输入数据
按预定的标准划分成不同的种类。例如，将某地区的人口按他们的年龄值age确定其类别就是一个分类问题，
见表4-1。

=== 第 114 页 ===
《数据结构导论》学习规划卡
第110页
用于描述分类过程的二叉树称为判定树。对上述分类问题可以画出两棵不同的判定树，如图4-23所示。
一棵判定树描述了一种分类方法，因而由给定的判定树很容易写出相应的分类算法。
图4-23a中判定树对应的分类算法描述如下：
通过这个算法，可由人的年龄值age确定其类别。
如果上述分类算法被频繁地重复使用，这时就需要考虑其时间性能。显然分类算法的主要工作是条件
判断，因此将条件判断作为标准操作是合理的。又由于分类算法的每一个条件判断对应于相应判定树上的
一个非终端结点，因而可以在判定树上讨论对应分类算法的时间复杂度。
以上述分类问题为例。假设该地区有人口N=10000人，并且各个类别的人数分布见表4-1中第三行所
示。对于每一类别的人，类别的人数乘以为区分该类别需做的比较次数等于为该类别的所有人确定类别所
需的比较次数。例如，以图4-23a所示的判定树作为求解分类问题的判定树，总人口数为N，C类别人口占
25%，为区分出某人是否属于C类别，需要进行3次比较，因而，为C类别的人确定类别共需进行N×0.25×3=

=== 第 115 页 ===
第四章树和二叉树
第111页10000×0.25×3=7500次比较。由此，为所有人确定类别所需的比较次数为
SUM=N×0.2×1+N×0.3×2+N×0.25×3+N×0.25×3
=N×(0.2+0.6+0.75+0.75)
=10000×2.3=23000
平均比较次数为SUM÷N=2.3
这就是说，依据任一人的年龄确定其类别，平均需做2.3次比较。
若按图4-23b的判定树对所有人的年龄确定类别，总比较次数为
SUM'=N×0.2×2+N×0.3×2+N×0.25×2+N×0.25×2
=N×(0.4+0.6+0.5+0.5)
=10000×2=20000
平均比较次数为SUM'÷N=2
相对图4-23a而言，图4-23b将少做3000次比较。平均比较次数也下降为2。这说明，按不同判定树进
行分类的计算量是不同的，有时可以相差很大。是否存在计算量最小（即平均比较次数最少）的判定树呢？
如果存在，怎样构造出这种判定树呢？下一节讨论的哈夫曼树和哈夫曼算法将给出这个答案。
知识点2哈夫曼（Huffman）树与哈夫曼算法【单选】★
（一）哈夫曼树
为解决上述问题，首先必须找出一种一般化的方法以确定任一判定树的平均比较次数。
设T是一判定树，其终端结点为n1，…，nk。每个终端络点ni对应的百分比为pi（即输入最终落入ni
的概率为p），这里
=1。通常将pi称为ni的权。再假定从根结点到ni之间的结点数为li，显然，为区分
出ni对应的分类结果需做li次比较。
例如，在图4-23b所示的判定树上，叶子B的祖先有两个，它们正好是为区分出类别B进行的两次比
较。按判定树T进行分类的平均比较次数为记为WPL(T)，则：
注意，图4-23中两棵判定树的平均比较次数的计算与上述公式一致。
现在，问题可重新表述为：给定一组值p1，…，pk，如何构造一棵有k个叶子且分别以这些值为权的判
定树，使得其平均比较次数最小。满足上述条件的判定树称为哈夫曼树。
（二）哈夫曼算法
哈夫曼率先给出了一个求哈夫曼树的简单而有效的方法，称为哈夫曼算法。非形式的描述如下：
（1）由给定的值{p1，…，pk}构造森林F={T1，…，Tk}，其中每个Ti为一棵只有根结点且其权为pi
的二叉树。
（2）从F中选取根结点的权最小的两棵二叉树Ti和Tj，构造一棵分别以Ti和Tj为左、右子树的新的

=== 第 116 页 ===
《数据结构导论》学习规划卡
第112页二叉树Th，置Th根结点的权为Ti、Tj根结点的权值之和。
（3）从F中删去Ti、Tj，并将Th加入F。若F中仍多于一棵二叉树，则返回②，直到F中只含一棵二
叉树为止，这棵二叉树就是哈夫曼树。
现在以表4-1为例，按上述哈夫曼算法求哈夫曼树的构造过程如图4-24所示。
由上述哈夫曼算法可知，假设初始森林中共有n棵二叉树，每棵树中都仅有一个孤立的结点，它们既
是根又是叶子。算法的第二步是将当前森林中的两棵根结点权值最小的二叉树合并成一棵新的二叉树，合
并一次，森林中就减少一棵树，显然要进行n-1次合并才能使森林中的二叉树的数目由n棵减少到只剩下一
棵最终的哈夫曼树，并且每次合并都要产生一个新结点。合并n-1次共产生n-1个新结点。由此可知，最终
求得的哈夫曼树中共有2n-1个结点，其中n个叶结点是初始森林中的n个结点，并且哈夫曼树中没有度数
为1的分支结点。
需要说明的是按照该算法构造的哈夫曼树不是唯一的，如图4-24a中也可以选A和D先合并成一棵二
叉树。在构造哈夫曼树的时候，初学者往往会进入一个误区，习惯性地用新得到的结点和其他结点构造二
叉树，而忽视了考虑是否权值最小。例如，在图4-24b中，用新得到的结点和结点D合并，再将新得到的
结点和B合并，这样得到的树并不是所要求的哈夫曼树。
设二叉树采用顺序存储。设置一个大小为2n-1的数组，令数组的每个元素由四个域组成，它们分别用
于存储权值、双亲指针和左、右孩子指针。用类C语言描述数组元素类型如下：


=== 第 117 页 ===
第四章树和二叉树
第113页
其中，树中每个结点包括四个域，w是结点的权值；lchild，rchild分别为结点的左、右孩子在数组中的下标
（也称为指针），parent是结点的双亲在数组中的下标。这里设置parent域不仅仅是为了使涉及双亲的运算
方便，它的主要作用是区分根和非根结点。之所以要区分根与非根结点，是因为在当前森林中合并两棵二
叉树时，必须在森林的所有根结点中找出两个权值最小的结点，因此有必要为每个结点设置一个用来区别
根和非根结点的标记。使用这种存储结构实现的哈夫曼算法描述如下：
（1）将表示哈夫曼树的数组T（类型为hftree）中的2n-1结点初始化；
（2）读入n个权值到数组T的前n个分量中，它们是初始森林中的n个孤立的根结点的权值；
（3）对森林中的树进行n-1次合并，共产生n-1个新结点，依次放入数组T的第i个分量中（n≤i<2*n-1）。
每次合并的步骤是：
①从当前森林的所有结点T[j](0≤j≤i-1)中选取具有最小权值和次小权值的两个根结点，分别用x和y
记住这两个根结点在数组T中的下标。
②将根为T[x]和T[y]的两个棵树合并，使它们分别成为新结点T[i]的左、右孩子，得到一棵以新结点
T[i]为根的二叉树。同时修改T[x]和T[y]的双亲域parent，使其指向新结点T[i]，这意味着它们在当前森林
已不再是根。将T[x]和T[y]的权值相加后作为新结点T[i]的权值。
类C语言描述的算法描述如下：


=== 第 118 页 ===
《数据结构导论》学习规划卡
第114页（三）哈夫曼树的构造过程
下面以图4-24中哈夫曼树的构造过程为例说明该算法。
本例构造哈夫曼树前给出四个结点，所以算法中k值为4。哈夫曼树的结点数为2×4-1=7（数组T的下
标从0到6，即T[0]到T[6]分别表示7个结点）。算法中对7个结点的权值初始化7个值，前四个是各结点
的权值，后三个均为0，并且各个结点的parent、lchild、rchild的值均初始化为-1。因为k值为4，所以要
合并3次。
第一次从下标值为0到3的结点中找权值最小的两个根结点（在该算法中parent的值为-1的结点）分
别是T[0]和T[2]，将这两个结点的权值相加作为新的结点T[4]的权值，得到T[4]的权值为0.45，修改T[0]
和T[2]的parent值为4，修改T[4]的lchild和rchild的值分别为0和2。
第二次从下标值为0到4的结点中找权值最小的两个根结点分别是T[1]和T[3]，将这两个结点的权值
相加作为新的结点T[5]的权值，得到T[5]的权值为0.55，修改T[1]和T[3]的parent值为5，修改T[5]的lchild
和rchild的值分别为1和3。
第三次从下标值为0到5的结点中找权值最小的两个根结点分别是T[4]和T[5]，将这两个结点的权值
相加作为新的结点T[6]的权值，得到T[6]的权值为1，修改T[4]和T[5]的parent值为6，修改T[6]的lchild
和rchild的值分别为4和5。
至此，哈夫曼树构造完毕，算法结束。
知识点3哈夫曼编码【应用】★
在通信领域，可以应用哈夫曼树来设计字符传输的编码。通常希望字符在传输过程中总的编码长度越
短越好。考虑到一个待传输的文本中不同字符出现的频率是不同的，直观的想法是让出现频率较多的字符
采用较短的编码，则传输的字符总编码长度会减少，究竟能否找到最短的编码方案？答案是肯定的，用哈
夫曼树就可以解决这一问题。
假设一个待传输的文本中共有n种不同的字符，每种字符出现的次数为wi，该种字符的编码长度为mi。
则总的码长度为
设总的字符个数为S，则
其中，pi是第i种字符的出现频率。可以看出，当平均码长达到最短时，文本总的码长也达到最短。
由上一节知识知道，将{p1，…，pn}作为一组叶结点的权值，用哈夫曼算法，可以构造出一棵具有最小
带权路径长度的二叉树，这个最小带权路径长度恰好是
该二叉树中每个结点的左分支标志“0”，每

=== 第 119 页 ===
第四章树和二叉树
第115页个结点的右分支标志为“1”，这样，从根到每个叶结点形“0”/“1”序列，将该序列作为叶结点对应字符
的编码，由此得到的二进制编码称为哈夫曼编码。
【例4-4】设某通信系统中一个待传输的文本有6个不同字符，它们的出现频率分别是0.5，0.8，1.4，
2.2，2.3，2.8，试设计哈夫曼编码。
【分析】由题意，共有n=6个不同的字符，字符的频率序列为p={0.5，0.8，1.4，2.2，2.3，2.8}，以这
些频率作为权值，构造一棵哈夫曼树，并对其进行哈夫曼编码，结果如图4-25所示。
出现频率为0.5的字符编码为1000
出现频率为0.8的字符编码为1001
出现频率为1.4的字符编码为101
出现频率为2.2的字符编码为00
出现频率为2.3的字符编码为01
出现频率为2.8的字符编码为11
【考点练习】
【真题·单选】在有n个叶子结点的哈夫曼树中，其结点总数为（）。
A.2n B.n-1
C.2n-1 D.2n+1
【答案】C
【解析】哈夫曼树中共有2n-1个结点，其中n个叶结点是初始森林中的n个结点，并且哈夫曼树中没有度
数为1的分支结点。

=== 第 120 页 ===
《数据结构导论》学习规划卡
第116页第五章图
►知识体系
►考点透析
知识点 考核要求 考试题型 重点星级
图的应用背景 识记
图的定义和术语 识记 单选、填空、应用 ★★★
邻接矩阵 简单应用 填空、应用 ★★
邻接表 简单应用 应用 ★
连通图的深度优先搜索 简单应用
连通图的广度优先搜索 简单应用 应用 ★
应用举例 领会
最小生成树 识记 单选、填空 ★★
拓扑排序 简单应用 单选、填空 ★★

=== 第 121 页 ===
第五章图
第117页第一节图的基本概念
►知识体系
在树形结构中，结点间具有层次关系，每一层结点只能和上一层中的至多一个结点相关，但可能和下
一层的多个结点相关。而在图结构中，任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意
的。图结构可以描述多种复杂的数据对象，应用较为广泛。
知识点1图的应用背景
现实中有很多实际问题可以用图（Graph）结构表示，进而可用计算机加以处理。
假如有这样一个问题：在N个城市间建立通信网络，使得其中的任意两个城市之间有直接或间接的通
信线路，假设已知每两个城市之间通信线路的造价，要求找出一个总造价最低的通讯网络。当N很大时，
这个问题十分复杂，只能借助计算机来求解。
这里有几个需要解决的问题：如何描述该问题的数据？如何在计算机中存储数据?解决问题的算法是什
么？可以用图结构来描述通信网络，用一个小圆圈代表一个城市，用小圆圈之间的连线代表对应两个城市
之间的通信线路，在连线旁边附加一个数值表示该通信线路的造价。图5-la所示为N=5的一种可能的通信
网络建造初步方案G0，它不是最优的，图5-1b为图5-la的一个优化后的最优方案G₀'。
这一描述形式就是图结构。其中的圆圈称为顶点，连线称为边，连线附带的数值称为边的权。图结构

=== 第 122 页 ===
《数据结构导论》学习规划卡
第118页可以采用多种存储结构来表示，这样上述通信网络问题借助图结构表示法即可以用计算机来处理。实际上，
对于图5-1所示的例子，利用计算机可以求出满足要求的造价最低的通信网络，并且保证所有城市之间可以
直接或间接连通。在5.2节中会介绍如何存储这些数据，在5.4节中得到解决问题的算法。
需要指出的是，现实世界中大量的实际问题可以用图来表示，通信网络只是其中之一。
知识点2图的定义和术语【单选、填空、应用】★★★
（一）图的定义及术语
（1）有向图、无向图：图G由两个集合V和E组成，记为G=(V，E)，其中，V是顶点的有穷非空集
合；E是边的集合，边是V中顶点的偶对。若顶点的偶对是有序的则称此图为有向图，有序偶对用尖括号<>
括起来；若顶点偶对是无序的，则称此图为无向图，无序偶对用圆括号()括起来。
例如，偶对<v，w>表示有向图中从顶点v到顶点w有一条边，即v，w∈V，<v，w>∈E。偶对(v，w)
表示无向图中顶点v和顶点w间有一条边，即v，w∈V，(v，w)∈E。
（2）弧、弧头、弧尾：有向图的边称为弧。设v，w∈V，若<v，w>∈E，则有序偶对<v，w>表示有
向图G中从v到w的一条弧，v称为弧尾或始点，w称为弧头或终点。特别注意的是在无向图中(v，w)与(w，
v)是同一条边，但在有向图中<v，w>与<w，v>是不同的两条弧。
在图5-2中，G1为有向图，它有四个顶点和五条弧，V={v0，v1，v2，v3}，E={<v0，v1>，<v1，v2>，
<v1，v0>，<v2，v0>，<v2，v3>}。G2为无向图，它有四个顶点和四条边，V={v0，v1，v2，v3}，E={(v0，v1)，
(v1，v2)，(v0，v2)，(v2，v3)}。
在无向图中，若顶点v与w间有边(v，w)，则v与w互为邻接点，称边(v，w)与顶点v和w相关联。
在有向图中，若顶点v与w间有弧<v，w>，则v与w邻接，称弧<v，w>与顶点v和w相关联。
任何两点之间都有边的无向图称为无向完全图。一个具有n个顶点的无向完全图的边数为
=n(n-1)/2。
任何两点之间都有弧的有向图称为有向完全图。一个具有n个顶点的有向完全图的弧数为
=n(n-1)。
（3）权、带权图：图的边附带数值，这个数值叫权。权在实际应用中可表示从一个顶点到另一个顶点

=== 第 123 页 ===
第五章图
第119页的距离、代价或耗费等。每条边都带权的图称为带权图。图5-1所示的图为带权图。
（4）顶点的度、入度、出度：无向图中顶点v的度是与该顶点相关联的边的数目，记为D(v)。如果G
是一个有向图，则把以顶点v为终点的弧的数目称为v的入度，记为ID(v)；把以顶点v为始点的弧的数目
称为v的出度，记为OD(v)。有向图中顶点v的度为入度与出度的和，即D(v)=ID(v)+OD(v)。对于图5-2
中G1，ID(v2)=1，OD(v2)=2，D(v2)=ID(v2)+OD(v2)=1+2=3。对于G2，D(v1)=2，D(v2)=3。
（5）子图：设G=(V，E)是一个图，若E'是E的子集，V'是V的子集，并且E'中的边仅与V'中的顶点
相关联，则图G'=(V'，E')称为图G的子图。
图5-3中所示的图为图5-2中G1的若干子图。图5-4中所示的图为图5-2中G2的若干子图。
（6）路径、路径长度：在无向图G=(V，E)中，从顶点v到顶点v'的路径是一个顶点序列：V，Vi1，
Vi2，…，Vim，V'，其中(v，Vi1)，(Vi1，Vi2)，…，(Vim，V')为图G中的边。若G是有向图，则要求这个顶
点序列满足：<v，Vi1>，<Vi1，Vi2>，…，<Vim，V'>为图G中的弧。路径上边（或弧）的数目称为路径长度。
例如，图5-2中无向图G2的顶点序列v0，v1，v2，v3和v0，v2，v3是顶点v0到顶点v3的两条路径，路
径长度分别为3和2。图5-2中有向图G1的顶点序列v0，v₁，v₂，v₃是顶点v₀到顶点v₃的一条路径，路径长
度为3，而顶点序列v0，v2，v3不是有向图G1中v0到顶点v3的路径。
（7）简单路径、回路、简单回路：序列中顶点不重复出现的路径称为简单路径。图5-2无向图G2中
v0→v1→v2→v3是简单路径。第一个顶点和最后一个顶点相同的路径称为回路或环。除了第一个顶点和最后
一个顶点外，其余顶点不重复的回路，称为简单回路或简单环。
如图5-2中无向图G2中的v0→v1→v2→v0→v2→v0和v0→v1→v2→v0都是回路，且v0→v1→v2→v0为简
单回路。
（8）连通、连通图、连通分量：在无向图中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。
如果图中的任意两个顶点vi和vj都是连通的，则称G为连通图。图5-2中G2是一个连通图。图5-5a中存
在多个不连通顶点。例如，v0和v3是不连通的，所以G3是非连通图，G3有两个连通分量，如图5-5b所示。
连通分量是无向图中的极大连通子图。

=== 第 124 页 ===
《数据结构导论》学习规划卡
第120页
（9）强连通、强连通图、强连通分量：对于有向图来说，如果图中任意一对顶点vi和vj（其中i≠j）
都有顶点vi到顶点vj的路径，也有从vj到vi的路径，即两个顶点间双向连通，那么称该有向图是强连通图。
有向图的极大强连通子图称为强连通分量。图5-2a的强连通分量如图5-6所示。
（10）生成树、生成森林：一个连通图的生成树，是含有该连通图的全部顶点的一个极小连通子图。
若连通图G的顶点个数为n，则G的生成树的边数为n-1。如果G的一个子图G'的边数大于n-1，则G'中一
定有环。相反，如果G'的边数小于n-1，则G'一定不连通。图5-7所示为G2的一棵生成树。在非连通图中，
由每个连通分量都可得到一个极小连通子图，即一棵生成树。那么这些连通分量的生成树就组成了一个非
连通图的生成森林。

=== 第 125 页 ===
第五章图
第121页
（二）图的基本运算
（1）建立图CreateGraph(G，V，E)：建立一个图G，其中V是G的顶点集合，E是G的边的集合；
（2）取顶点信息GetVex(G，u)：获取图G中顶点u的信息；
（3）取边信息Getarc(G，u，v)：获取图G中边(u，v)或<u，v>的信息；
（4）查询第一个邻接点FirstVex(G，u)：获取图G中顶点u的第一个邻接点；
（5）查询下一个邻接点NextVex(G，u，v)：已知v是u的一个邻接点，获取图G中顶点u的下一个
邻接点；
（6）插入顶点InsertVex(G，v)：在图G中插入一个顶点v；
（7）删除顶点DeleteVex(G，v)：在图G中删除一个顶点v；
（8）插入边InsertArc(G，v，w)：在图G中插入一条边(v，w)或<v，w>；
（9）删除边DeleteArc(G，v，w)：在图G中删除一条边(v，w)或<v，w>；
（10）遍历图Traverse(G，tag)：遍历图G，使G中每个顶点被访问一次且仅被访问一次，当tag=0，
则遍历的方法为深度优先搜索，当tag=1，则遍历的方法为广度优先搜索。
【考点练习】
【真题·单选】一个具有n个顶点的无向完全图的边数为（）。
A.0 B.n(n-1)/2
C.n(n-1) D.n(n+1)
【答案】B
【解析】n个顶点的无向完全图边数为n(n-1)/2，n个顶点的有向完全图边数为n(n-1)。
【真题·填空】在图中，序列中顶点不重复出现的路径称为______路径。

=== 第 126 页 ===
《数据结构导论》学习规划卡
第122页【答案】简单
【真题·填空】任何两点之间都有边的无向图称为无向______图。
【答案】完全
第二节图的存储结构
►知识体系
图的存储结构有多种。例如，邻接矩阵、邻接表、十字链表和邻接多重表等
知识点1邻接矩阵【填空、应用】★★
邻接矩阵就是用矩阵来描述图中顶点之间的关联关系，在程序设计语言中很容易用二维数组来实现矩阵。
设G=(V，E)是一个图，其中V={v0，v1，…，vn-1}，那么G的邻接矩阵A定义为如下的n阶方阵：
图5-2中有向图G1和无向图G2的邻接矩阵分别为M1和M2：
注意：无向图的邻接矩阵是一个对称矩阵，例如M2。
用邻接矩阵表示法来表示一个具有n个顶点的图时，除了用邻接矩阵中的n×n个元素存储顶点间相邻
关系外，往往还需要另设一个数组存储n个顶点的信息。类型定义如下：

=== 第 127 页 ===
第五章图
第123页
将上述类型定义存放到描述图的头文件Graphm.h中。
利用邻接矩阵可以判定任意两个顶点之间是否有边，并容易求得各个顶点的度。对于无向图，顶点vi
的度是邻接矩阵中第i行（或第i列）的元素之和，即
对于有向图，顶点vi的出度OD(vi)是邻接矩阵中第i行元素之和，顶点vi的入度ID(vi)是邻接矩阵中第
i列元素之和，即
用邻接矩阵也可以表示带权图，只要令
其中，wij为<vi，vj>或(vi，vj)上的权值。在计算机中可以用int型的最大整数值32767表示∞。相应地，
带权图的邻接矩阵表示的类型定义作如下的修改。
将上述类型定义存放到头文件Graphm.h中。
图5-8给出一个带权图和它的邻接矩阵。

=== 第 128 页 ===
《数据结构导论》学习规划卡
第124页
无向带权图的邻接矩阵的建立方法是：首先将矩阵A的每个元素都初始化为最大值，然后读入边及权
值(i，j，wij)，将A的相应元素置成wij。无向带权图邻接矩阵的建立算法描述如下：


=== 第 129 页 ===
第五章图
第125页
知识点2邻接表【应用】★
邻接表是顺序存储与链式存储相结合的存储方法。在邻接表中，对图中每个顶点建立一个单链表。对
于无向图，第i个单链表中的结点表示依赖于顶点vi的边，对于有向图是以顶点vi为尾的弧，这个单链表
称为顶点vi的邻接表。每一个单链表设一个表头结点，每一个表头结点有两个域vertex和firstarc，vertex
用来存放顶点vi的信息，firstarc用来指向邻接表中的第一个结点。为了便于随机访问，将所有单链表的头
结点组成一个一维数组Adjlist。单链表中每一个结点称为表结点，包括两个域：邻接点域（adjvex）和链域
（nextarc），邻接点域用以存放与vi相邻接的顶点在数组Adjlist中的序号，链域用以指向同vi邻接的下一
个结点。在带权图的表结点中增加一个权值域，用于存储边的权值（weight）。表头结点和表结点的形式如
图5-9所示。
图5-2中无向图G2的邻接表表示如图5-10所示。
邻接表的类型定义如下。

=== 第 130 页 ===
《数据结构导论》学习规划卡
第126页
将上述类型定义存放到头文件Graphlk.h中。
如果一个无向图有n个顶点，e条边，那么它的邻接表需要n个头结点和2e个表结点。显然，在边稀
疏(e<<n(n-1)/2)的情况下，用邻接表表示比用邻接矩阵节省存储空间。
下面讨论在邻接表上如何求顶点的度。无向图中顶点vi的度恰为第i个单链表中的结点数。对有向图，
第i个单链表中的结点个数只是顶点vi的出度。为了求入度，必须遍历整个邻接表。在所有单链表中，其邻
接点域的值为i的结点的个数是顶点vi的入度。
对于有向图，有时需要建立一个逆邻接表，即对每个顶点vi建立一个以vi为弧头的邻接点的链表。这
同邻接表正好相反。对于逆邻接表可以很容易求出vi的入度。图5-2中G1的邻接表和逆邻接表如图5-11
所示。
同理，我们可以给出图5-1a无向带权图的邻接表如图5-12a所示，图5-8a有向带权图的邻接表如图5-12b
所示和逆邻接表如图5-12c所示。

=== 第 131 页 ===
第五章图
第127页
建立有向图的邻接表的方法是：首先将邻接表表头数组初始化，第i个表头的vertex域初始化为i，firstarc
域初始化为NULL。然后读入顶点对<i，j>，产生一个表结点，将j放入到该结点的adjvex域，将该结点链
到邻接表的表头数组的第i个元素的firstarc域上。
建立有向图的邻接表的算法描述如下：


=== 第 132 页 ===
《数据结构导论》学习规划卡
第128页与邻接矩阵能方便地对顶点进行随机访问不同，在邻接表中要判定任意两个顶点vi和vj之间是否有边
相连，需要遍历第i个或第j个单链表，因此，对于图来说使用邻接矩阵或邻接表作存储结构各有利弊。
【考点练习】
【真题·填空】无向图的邻接矩阵是一个______矩阵。
【答案】对称
【真题·应用】根据有向图的邻接表回答下列问题：
（1）如何判断图中有多少条弧？
（2）如何判断图中是否存在从顶点i到顶点j的弧？
（3）如何求顶点i的出度？
【答案】（1）图中弧的条数为邻接表的表结点的个数。
（2）要判断图中是否存在从i到j的弧，只要看第i个表头结点的链表中是否存在adjvex为j的表结点。
（3）顶点i的出度即为：第i个表头结点的链表中表结点的个数。
第三节图的遍历
►知识体系
图的遍历是指从图的某个顶点出发，系统地访问图的每个顶点，并且每个顶点只被访问一次。
遍历图的基本方法有两种：深度优先搜索和广度优先搜索。这两种方法都适用于有向图和无向图。图
的遍历操作类似于树的遍历操作。
由于图的任一顶点都可能和其余顶点相邻接，因此在遍历图的过程中，可能会多次访问某个顶点。为

=== 第 133 页 ===
第五章图
第129页避免这种情况，要记下每个已访问过的顶点。一般可增设一个辅助数组visited[n]，每个visited[i]初值置为
零。一旦顶点vi被访问，就将visited[i]置为1。
知识点1连通图的深度优先搜索
（1）基本思想
连通图深度优先搜索的基本思想：假定以图中某个顶点vi为出发点，首先访问出发点vi，然后任选一
个vi的未访问过的邻接点vj，以vj为新的出发点继续进行深度优先搜索，依此类推，直至图中所有顶点都
被访问过。深度优先搜索遍历类似于树的先序遍历。
显然，图的深度优先搜索可以看成一个递归过程。
（2）深度优先搜索的过程
现以图5-13a中G4为例说明深度优先搜索的过程。
假设v0是出发点，首先访问v0，接下来应访问v0的邻接点，因v0有三个邻接点v1，v3和v5，它们都
未被访问过，在这三个顶点中任选一个作为新的出发点，现选择v1。
访问v1后，再找v1的未被访问过的邻接点v2，选择v2作为新的出发点。
v2有三个邻接点分别为v1，v3和v4，其中v1已经被访问过，可在v3和v4中选择一个，现选择v4，v4
又有三个邻接点v2，v3和v5，由于v2被访问过，可从v3和v5中任选一个，现选择v3作为新的出发点，而
v3的邻接点v0，v2和v4都被访问过，那么搜索回到v4，这时由于v4的另一个邻接点v5未被访问，搜索从
v4到v5。从而遍历了图中的全部顶点。
在这个过程中得到的一个深度优先搜索的顶点访问序列为v0→v1→v2→v4→v3→v5。
搜索过程如图5-13b所示。在图5-13b中，箭头指示顶点访问顺序（不是代表弧），带箭头的连线旁的
数字表示顶点访问的次序。

=== 第 134 页 ===
《数据结构导论》学习规划卡
第130页（3）需要注意的点
①搜索到达某个顶点时（图中仍有顶点未被访问），如果这个顶点的所有邻接点都被访问过，那么搜
索就要回到前一个被访问过的顶点，再从该顶点的下一未被访问的邻接点开始深度优先搜索；
②深度搜索的顶点的访问序列不是唯一的。
（4）连通图的深度优先搜索的算法描述
连通图的深度优先搜索的算法描述如下：
算法中设置了一个visited数组，visited[v]初值置为零，在算法执行过程中，如果顶点v已被访问，则
置visited[v]为1。
上述算法中未涉及图的存储结构。图的遍历过程必然地包含对图中每个顶点查找其邻接点这一操作；
而在图的不同存储结构上查找邻接点的方法是不同的。
如果以邻接表为存储结构，查找邻接点操作实际上是顺序查找链表，相应的深度优先搜索算法描述如下：
这里，数组visited为全局量。在第一次调用Dfs前，需将数组visited的每个元素初始化为0。以邻接
表为存储结构，深度优先搜索算法的时间复杂度是O(n+e)，其中n为图的顶点数，e为图的边数。
如果采用邻接矩阵作为存储结构，查找邻接点操作实际上通过循环语句顺序访问邻接矩阵的某一行。
相应的深度优先搜索算法描述如下：

=== 第 135 页 ===
第五章图
第131页
visited作为一个全局量，未通过参数表传递。采用邻接矩阵作为存储结构，深度优先搜索算法的时间
复杂度是O(n²)，其中n为图的顶点数。
知识点2连通图的广度优先搜索【应用】★
（1）基本思想
连通图广度优先搜索的基本思想是：从图中某个顶点vi出发，在访问了vi之后依次访问vi的所有邻接
点，然后依次从这些邻接点出发按广度优先搜索方法遍历图的其他顶点，重复这一过程，直至所有顶点都
被访问到。广度优先搜索遍历类似于树的按层次遍历的过程。
（2）广度优先搜索的过程
下面以图5-13中G4为例说明广度优先搜索的过程。
首先从起点v0出发，访问v0。v0有三个未被访问的邻接点v1，v3和v5。
先访问v1，再访问v3，后访问v5。
然后访问v1的未被访问过的邻接点v2，再访问v3的未被访问的邻结点v4。
至此图中所有顶点均已被访问到。得到的顶点访问序列为v0→v1→v3→v5→v2→v4。此搜索过程如图5-14
所示。
（3）广度优先搜索算法的描述

=== 第 136 页 ===
《数据结构导论》学习规划卡
第132页在广度优先搜索中，若对x的访问先于y，则对x的邻接点的访问也先于对y的邻接点的访问，也就是
说广度优先搜索邻接点的寻找具有先进先出的特征。因此，为了保证结点的这种先后关系，可采用队列来
暂存那些刚访问过的顶点。连通图的广度优先搜索算法描述如下：
上述算法未涉及图的存储结构。若图的存储结构为邻接表，队列采用链队列，相应的广度优先搜索算
法描述如下：


=== 第 137 页 ===
第五章图
第133页
同样，这里的数组visited为全局量。在调用Bfs前，需将数组visited的每个元素初始化为0。
如果采用邻接矩阵作为存储结构，查找邻接点操作实际上通过循环语句顺序访问邻接矩阵的某一行。
相应的广度优先搜索算法描述如下：
知识点3应用举例
上面讲述了连通图的遍历是通过深度优先搜索或广度优先搜索完成的。这里要特别说明遍历和搜索两
个概念的区别。前面说过，图的遍历是访问图每个顶点一次且仅一次，而搜索是从一个顶点出发访问到所
有能访问的顶点一次且仅一次；若图是非连通图，需多次调用搜索过程Dfs或Bfs。每一次调用后都得到此
非连通图的一个连通分量。在遍历整个图时，调用Dfs或Bfs的次数就是连通分量的个数。因此，很容易写

=== 第 138 页 ===
《数据结构导论》学习规划卡
第134页出非连通图的遍历算法和计算一个图的连通分量的算法。
下面给出的是以邻接表为存储结构，通过调用深度优先搜索算法实现的计算连通分量的算法。
该算法中，每个连通分量所包含的顶点，在每次调用的Dfs中输出。
【例5-1】利用连通分量计算算法求出图5-5中非连通图G3连通分量的个数。
【分析】
在for(v=0;v<g.vexnum;v++)循环体内，初始v=0，算法中从v0出发，由于顶点v0未被访问，连通分量
个数加1，即count++，调用Dfs(g，v0)，在Dfs调用过程中，通过递归调用，依次访问v0，v1，v2，Dfs调
用返回到for(v=0;v<g.vexnum;v++)，循环体内，循环控制变量v=1，v1已被访问过，即visited[1]=1，不执
行Dfs，取v=2，v2已被访问过，即visited[2]=1，不执行Dfs，取v=3，由于顶点v3未被访问，连通分量个
数加1，即count++，调用Dfs(g，v3)，在Dfs调用过程中，通过递归调用，依次访问v3和v4，Dfs调用返回
到for(v=0;v<g.vexnum;v++)循环体内，取v=4，v4已被访问过，即visited[4]=1，这样在for(v=0;v<g.vexnum;v++)
循环执行完毕。
用上述算法可求出两个连通分量，各连通分量所含顶点如下：
连通分量1包含以下顶点：012
连通分量2包含以下顶点：34
共有2个连通分量。
注意，若从上述算法中删去有关连通分量计数器的操作，就得到一个非连通图的遍历算法。

=== 第 139 页 ===
第五章图
第135页【考点练习】
【真题·应用】如图所示的图结构，请写出以10为源点的广度优先搜索得到的顶点访问序列，并画出搜索过
程图。（同等情况下，值小的结点优先访问）。
【答案】序列：10，20，30，50，40，60
搜索过程图：
第四节图的应用
►知识体系
知识点1最小生成树【单选、填空】★★
（1）最小生成树的概念
下面介绍图的一种重要应用——求最小生成树。连通图的一次遍历所经过边的集合及图中所有顶点的集
合就构成该图的一棵生成树。我们知道连通图的遍历序列不是唯一的，所以能得到不同的生成树。图5-15

=== 第 140 页 ===
《数据结构导论》学习规划卡
第136页为无向图G4的几棵生成树。
可以证明，对于有n个顶点的无向图，所有生成树中都有且仅有n-1条边。
一个图的最小生成树是图所有生成树中权总和最小的生成树。最小生成树的概念可以应用到很多实际
问题中。例如，以尽可能低的造价建造各个城市之间的通信网络。在网络中，每个顶点表示一个城市，顶
点之间的边表示城市之间可构造的通信线路，每条边的权值表示建造这条通信线路的经济代价，如何使网
络的总代价最低？实际上就是寻找该网络的最小生成树。一棵生成树的代价就是树上各边的代价之和。下
面介绍构造最小生成树的算法：
（2）构造最小生成树的Prim算法
Prim算法的基本思想如下。假设G=(V，E)是一个带权图，生成的最小生成树为MinT=(V，T)，其中V
为顶点的集合，T为边的集合。
求T的步骤如下：
①初始化：U={u0}，T={}。其中U为一个新设置的顶点的集合，初始U中只含有顶点u0，这里假设
在构造最小生成树时，从顶点u0出发；
②对所有u∈U，v∈V-U（其中u，v表示顶点）的边（u，v）中，找一条权最小的边（u'，v'），将这
条边加入到集合T中，将顶点v'加入到集合U中；
③如果U=V，则算法结束；否则重复第②、③步。
最后得到最小生成树MinT=<V，T>，其中T为最小生成树的边的集合。
求图5-16a中带权图的最小生成树的过程如图5-16b、c、d、e所示。图5-16a为一个带权图，V={0，1，
2，3，4}（为方便叙述，用顶点的序号表示顶点），此时设U={0}，V-U={1，2，3，4}，在U={0}和V-U={1，
2，3，4}相关联的所有边中(0，4)的权值最小，因此取(0，4)为最小生成树的第一条边，如图5-16b所示；
此时U={0，4}，V-U={1，2，3}，在所有U={0，4}和V-U={1，2，3}相关联的边中，(4，2)的权值最小，
取(4，2)为最小生成树的第二条边，如图5-16c所示；现在U={0，4，2}，V-U={1，3}，在所有U={0，4，
2}和V-U={1，3}相关联的边中，(2，1)的权值最小，取(2，1)为最小生成树的第三条边，如图5-16d所示；

=== 第 141 页 ===
第五章图
第137页这样U={0，4，2，1}，V-U={3}，在所有U={0，4，2，1}和V-U={3}相关联的边中，(2，3)的权值最小，
取(2，3)为生成树的第四条边，如图5-16e所示。最后U={0，4，2，1，3}，V-U={}。图5-16e为最终得到
的最小生成树，此时U=V。在这个过程中要注意，在求权值最小边时，要求u∈U，v∈V-U，从所有这样
的边(u，v)中求出权值最小的边(u，v)。
实线圈里的结点表示集合U中结点的变化情况，虚线表示被选入集合T中的边。
带权图的存储结构用邻接矩阵表示。若两个顶点之间不存在边，其权值为计算机内允许的最大值，用
MAX_INT表示；否则为对应边上的权值。设立一个辅助数组closedge，它的每个下标变量有两个域：顶点
（adjyex）和最小代价（lowcost），记录从U到V-U具有最小代价的边。数据结构定义如下：

=== 第 142 页 ===
《数据结构导论》学习规划卡
第138页
算法描述如下：
【例5-2】利用Prim算法求图5-16a最小生成树，并给出过程描述。
【分析】图5-16a带权图的邻接矩阵如图5-17所示，若从顶点v0出发，用Prim算法求其最小生成树的
过程见表5-1。

=== 第 143 页 ===
第五章图
第139页
在表5-1中，顶点0是初始顶点，在U={0}和V-U={1，2，3，4}间，边(0，4)具有最小代价20，输出
顶点4，并将4加入到U中，则U={0，4}，V-U={1，2，3}，由于4加入到集合U，需要调整U和V-U之
间顶点对的最小代价，可以看出(4，2)的代价比(0，2)更小，将closedge[2].lowcost调整为30，closedge[2].adjvex
调整为4。接下来，在U={0，4}和V-U={1，2，3}间，边(4，2)具有最小代价30，输出顶点2，并将2加
入到U中，则U={0，2，4}，V-U={1，3}，由于2加入到集合U，需要调整U和V-U之间顶点对的最小
代价，可以看出(2，1)的代价比(0，1)更小，将closedge[1].lowcost调整为10，closedge[1].adjvex调整为2，
(2，3)的代价比(0，3)更小，将closedge[3].lowcost调整为20，closedge[3].adjvex调整为2。在U={0，2，4}
和V-U={1，3}间，边(2，1)具有最小代价10，输出顶点1，并将1加入到U中，这时，没有需要调整的代
价。最后找出U={0，1，2，4}，V-U={3}间的最小代价，边(2，3)具有最小代价20，将3加入到U中，则
U={0，1，2，3，4}，V-U={}，至此，求出了最小生成树。
（3）构造最小生成树的克鲁斯卡尔方法
克鲁斯卡尔（Kruskal）算法是另一种构造最小生成树的方法，这里给出该算法的思想。
①设G=(V，E)，令最小生成树初始状态为只有n个顶点而无边的非连通图T=(V，{})，每个顶点自成
一个连通分量；
②在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，
否则，舍去此边，选取下一条代价最小的边；

=== 第 144 页 ===
《数据结构导论》学习规划卡
第140页③依此类推，重复②，直至T中所有顶点都在同一连通分量上为止。
在图5-18a为初始图，图5-18b含5个结点，不含边，这样该图有5个连通分量，每个顶点是一个连通
分量，由于边(v1，v2)的权值最小，这个代价最小边的两个顶点落在两个不同的连通分量上，添加该边后不
构成回路，选择(v1，v2)添加到图5-18b中形成图5-18c，图5-18c中有四个连通分量；由于边(v0，v4)是剩余
边中的权值最小的，同理，添加该边后不构成回路，选择(v0，v4)添加到图5-18c中，形成图5-18d，接下来
由于边(v2，v3)是剩余边中的权值最小的，添加该边后不构成回路，选择(v2，v3)添加到图5-18d中形成图5-18e，
最后由于边(v2，v4)是剩余边中的权值最小的，添加该边后不构成回路，添加到图5-18e中形成图5-18f，至
此，最小生成树构造完成。
（4）单源最短路径
找最短路径是实际生活中常见的问题。例如，在旅游的时候，从某地出发，要到某个目的地，如何选
择路径，才能使得路程最短。这个问题就涉及最短路径问题。给定一个带权有向图G=(V，E)，其中每条边
的权是非负实数。另外，给定V中的一个顶点，称为源。要计算从源到其他各顶点的最短路径长度。这里
的长度是指路径上各边权值之和。这个问题通常称为单源最短路径问题。
Dijkstra算法求单源最短路径问题的基本思想是：设置顶点集合S，开始时S中只含有源点v。设u是
G的某一个顶点，把从源点v到u且中间只经过S中顶点的路径称为从源到u的特殊路径，并用数组dist
记录当前从源点v到其他每个顶点所对应的最短特殊路径长度，dist[u]的初值设置为弧<v，u>的权值，若弧
<v，u>不存在，则dist[u]的初值设置为∞，或用MAX_INT表示。Dijkstra算法每次从V-S中取出具有最短

=== 第 145 页 ===
第五章图
第141页特殊路径长度的顶点u，将u添加到S中，如果dist[u]+g.arcs[u][j]<dist[j]，则对数组dist做必要的修改，即
将dist[j]的值改为dist[u]+g.arcs[u][j]，这里g.arcs[u][j]表示图中弧<u，j>的权值。当S包含了所有V中顶点
时，dist就记录了从源到所有其他顶点的最短路径长度，即dist[u]表示最终从源点v到顶点u的最短路径长度。
例如，对图5-19中的有向图G5，应用Dijkstra算法思想计算从源顶点v0到其他顶点间最短路径的过程
列在表5-2中。
【例5-3】应用Dijkstra算法计算图5-19中的有向图G5从源顶点v0到其他顶点间最短路径，用图示给
出求解的过程。
【分析】用Dijkstra算法思想求解v₀到其他顶点间最短路径见表5-2，共四步。
第1步，分别列出了<v0，v1>，<v0，v2>，<v0，v3>三条弧的距离值，分别为dist[1]、dist[2]、dist[3]，
这也就是当前v0分别到v1，v2，v3的最短距离。其中，v0到v1距离最短，长度为20；
第2步，将v1加入到集合S中，由于v1加入S，从v0经v1到v2的距离80比从v0直接到v2的距离MAX_INT
小，需要调整dist[2]=80，从v0经v1到v3的距离50不比从v0直接到v3的距离40小，dist[3]不作调整，这
时v0到v3具有最短距离值，长度为40；
第3步，将v3加入到集合S中，由于v3的加入，从v0经v3到v2的距离50比从v0经v1到v2的距离80
小，所以需要调整dist[2]=50，这时v0到v2具有最短距离值，长度为50；
第4步，将v2加入到集合S中，这时S=V，已求出v0到其他顶点的最短路径。

=== 第 146 页 ===
《数据结构导论》学习规划卡
第142页知识点2拓扑排序【单选、填空】★★
在工程实践中，一个工程项目往往由若干个子项目组成，这些子项目间往往有两种关系；
①先后关系，即必须在一子项目完成后，才能开始实施另一个子项目；
②子项目间无关系，即两个子项目可以同时进行，互不影响。
在工厂产品生产过程中，一个产品由若干个零部件组成。零部件生产时，也存在这两种关系：先后关
系，即必须在一个部件完成后才能生产另一个部件；部件生产相互之间无先后关系，即这两个部件可以同
时生产。
大学里某个专业的课程学习，有些课程是基础课，它们可独立于其他课程，即无前导课程；有些课程
必须在某些基础课学完后才能开始学习。这类问题都可以用有向图来进行描述，我们把这些子项目、零部
件、课程看成是一个个顶点，把那些有前后关系的顶点用一条有向边连接。现在要从这些有向图上分别找
出一个施工流程图、产品生产流程图、课程学习流程图，以便顺利进行施工、产品生产和课程学习，解决
这些问题可以采用拓扑排序的方法。
（一）AOV网
工程或者某种流程可以分为若干个小的工程或阶段，这些小的工程或阶段就称为活动。如果以图中的
顶点来表示活动，有向边表示活动之间的优先关系，这种用顶点表示活动的有向图称为AOV网。AOV网
中的弧表示了活动之间存在着的制约关系。
假定计算机软件专业的课程之间存在表5-3所示的关系。
课程之间的先后关系可用图5-20所示的有向图表示。

=== 第 147 页 ===
第五章图
第143页
（二）拓扑排序
设G=（V，E）是一个具有n个顶点的有向图，V中顶点的序列v1，v2，…，vn称为一个拓扑序列，当
且仅当该顶点序列满足下列条件：若在有向图G中，从顶点vi到vj有一条路径，则在拓扑序列中顶点vi必
须排在顶点vj之前。找一个有向图的一个拓扑序列的过程称为拓扑排序。完成拓扑排序的前提条件是AOV
网中不允许出现回路。
（1）向图拓扑排序算法的步骤
下面给出有向图拓扑排序算法的基本步骤：
①图中选择一个入度为0的顶点，输出该顶点；
②从图中删除该顶点及其相关联的弧，调整被删弧的弧头结点的入度（入度减1）；
③重复执行①、②直到所有入度为0的顶点均被输出，拓扑排序完成，或者图中再也没有入度为0的
顶点。
可以证明，任何一个无环有向图，其全部顶点可以排成一个拓扑序列。
图5-21给出了一个在AOV网上实施上述步骤的例子。

=== 第 148 页 ===
《数据结构导论》学习规划卡
第144页
这样便得到一个拓扑序列为C1，C2，C5，C4，C3。
【例5-4】求图5-22a所示有向图顶点的拓扑序列，图5-22b是它的邻接表，在表头结点中增加一个数
据域in表示相应顶点的入度。
首先C0、C3的入度都为0，选C0，删除C0及其边e1、e2，调整C1的入度为0，C2的入度为1，此
时C1、C3的入度为0，选C3，删除C3及边e3，调整C2的入度为0，从C1、C2中选C1，删除C1及边

=== 第 149 页 ===
第五章图
第145页e4，调整C4的入度为1，选择C2，删除C2及边e5，调整C4的入度为0，输出C4，至此拓扑排序完成，
拓扑序列为C0，C3，C1，C2，C4。
（2）拓扑排序算法描述
下面以邻接表作存储结构，给出拓扑排序算法的实现。算法中设置一个链栈，将所有入度为0的顶点
压入该栈。选择入度为0的顶点，只要从栈中弹出一个元素即可。删除边的操作转化为将以该顶点为弧尾，
所有相应弧头的入度减1。在邻接表的表头中增加一个入度域in（图5-22b）。
算法修改如下：


=== 第 150 页 ===
《数据结构导论》学习规划卡
第146页
拓扑排序算法的时间复杂度为O(n+e)，n是图的顶点个数，e是图的弧的数目。上述拓扑排序算法中采
用栈来存放入度为0的结点，这里要特别说明，算法中也可以采用队列来存放入度为0的结点。
将邻接矩阵的类型定义和带权图邻接矩阵的类型定义存放到头文件Graphm.h，将邻接表的类型定义存
放到头文件Graphlk.h中。

=== 第 151 页 ===
第五章图
第147页【考点练习】
【真题·单选】设含有n个顶点，e条弧的有向图G采用邻接表存储，则拓扑排序算法的时间复杂度为（）。
A.O(n) B.O(n+e)
C.O(n2) D.O(n×e)
【答案】B
【解析】拓扑排序算法在有向图上的时间复杂度通常是O(n+e)，其中n是顶点的数量，e是边的数量。
【真题·填空】Dijkstra算法用于求______问题。
【答案】单源最短路径
【真题·填空】完成拓扑排序的前提条件是AOV网中不允许出现______。
【答案】回路

=== 第 152 页 ===
《数据结构导论》学习规划卡
第148页第六章查找
►知识体系


=== 第 153 页 ===
第六章查找
第149页►考点透析
知识点 考核要求 考试题型 重点星级
查找表的概念 领会
查找表的基本运算 识记 填空
顺序表上的查找 简单应用 填空
有序表上的查找 简单应用 单选、应用 ★★
索引顺序表上的查找 领会
二叉排序树的概念 识记
二叉排序树上的查找 领会 单选
二叉排序树的插入 领会 应用 ★
二叉排序树的查找分析 领会 单选
常用散列法 领会 单选 ★
散列表的实现 简单应用 单选、应用 ★★★
散列表的基本操作算法 领会

=== 第 154 页 ===
《数据结构导论》学习规划卡
第150页第一节基本概念
►知识体系
知识点1查找表的概念
查找表（SearchTable）是由同一类型的数据元素构成的集合，它是一种以查找为“核心”，同时包括
其他运算的非常灵活的数据结构。
这里的集合和数学上的定义基本一致，简单地说就是由任意一些可分辨的对象构成的整体。例如，所
有正整数放在一起构成一个集合，称为正整数集；所有学生的成绩放在一起也是一个集合，称为成绩集。
通常要求同一个集合的各个元素是互不相同的，即要求集合中没有相同元素。另外，规定空集是不含任何
元素的集合，记为
。
作为一个数学概念，集合的元素没有任何限制。也就是说，无论是什么对象，也无论这些对象的特性
是否相同，都可以作为一个集合中的元素。但在数据结构课程中，通常只考虑那些由相同类型的数据元素
构成的集合。
为了便于讨论，先给出大学职工信息表的片断，见表6-1，然后引入相关概念。
查找就是从大量的数据元素中找出某个指定的数据元素。为了便于标识这个数据元素，引入关键字的
概念。关键字，简称键，是数据元素中某个数据项，可以用来标识数据元素，该数据项的值称为键值。关
键字分为主关键字和次关键字两种。主关键字可以唯一标识一个数据元素，即对于不同的数据元素其主关
键字均不同；次关键字则可以识别若干数据元素。在表6-1中，“工号”是主关键字，每个职工的工号是不
同的。而在同一个院系、同一个学校可能会出现同名同姓的职工，“性别”只有“男”或“女”两种值，

=== 第 155 页 ===
第六章查找
第151页因此，“姓名”、“性别”等都是次关键字。原则上，任何数据项都可作为关键字，至于选择哪个数据项
作为关键字应根据实际问题的需要来决定。在本章中若无特别声明，将默认选定的是主关键字。另外，为
简单起见，本章有时假定所有数据元素只含关键字，不含其他数据域。
知识点2查找表的基本运算【填空】
采用上述术语，查找运算可以更确切地表述如下：
根据给定的某个值，在查找表中寻找一个其键值等于给定值的数据元素。若找到一个这样的数据元素，
则称查找成功，此时的运算结果为该数据元素在查找表中的位置；否则，称查找不成功，此时的运算结果
为一个特殊标志。
作为一种数据结构，查找表的逻辑结构是集合，对查找表进行的操作包括查找表中某一元素、读取表
中“特定”数据元素、插入和删除一个数据元素等。
若对查找表只进行前两项操作，则称此类查找表为静态查找表。
若在查找过程中，向表中插入不存在的数据元素，或者从表中删除某个数据元素，则称此类表为动态
查找表。
（1）静态查找表
静态查找表是以具有相同特性的数据元素集合为逻辑结构，包括下列三种基本运算（但不包括插入和
删除运算）：
①建表Create(ST)：操作结果是生成一个由用户给定的若干数据元素组成的静态查找表ST；
②查找Search(ST，key)：若ST中存在关键字值等于key的数据元素，操作结果为该数据元素的值，否
则操作结果为空；
③读表中元素Get(ST，pos)：操作结果是返回ST中pos位置上的元素。
（2）动态查找表
动态查找表也是以集合为逻辑结构，包括下列五种基本运算：
①初始化Initiate(ST)：设置一个空的动态查找表ST；
②查找Search(ST，key)：同静态查找表；
③读表中元素Get(ST，pos)：同静态查找表；
④插入Insert(ST，key)：若ST中不存在关键字值等于key的元素，则将一个关键字值等于key的新元
素插入到ST中；
⑤删除Delete(ST，key)：当ST中存在关键字值等于key的元素时，将其删除。
对于静态查找表，其主要运算是在建表后所进行的检索（包括查找和读表中元素运算），而在动态查
找表中检索和修改操作是相互交叉的。

=== 第 156 页 ===
《数据结构导论》学习规划卡
第152页【考点练习】
【真题·填空】若在查找过程中，向表中插入不存在的数据元素，或者从表中删除某个数据元素，则称此类
表为______查找表。
【答案】动态
第二节静态查找表
►知识体系
知识点1顺序表上的查找【填空】
（1）静态查找的定义
静态查找表最简单的实现方法是以顺序表作为存储结构，这里只考虑查找的实现。
静态查找表顺序存储结构的类型定义如下：
这里，将静态查找表中的数据元素存放在上述数组的第1到第n个单元中，第n+1到最后一个单元为
备用区（空闲区），如图6-1所示。数组的第0个单元，用于设置“岗哨”，以便简化查找运算的实现。

=== 第 157 页 ===
第六章查找
第153页
在上述存储结构上实现顺序查找操作，其过程为从表的最后一个数据元素位置开始，从后往前依次将
各个位置上的数据元素的键值与给定值比较。若某个位置上的数据元素的键值与给定值相等，则查找成功，
并返回该位置作为结果；反之，若查找至第一个元素，所有数据元素的键值均与给定值不等，则查找不成功。
（2）查找算法描述
本算法独特之处在于在查找之前对T.elem[0].key赋以待查的key，这样，算法中免去了每次查找都要检
测整个表是否查找完毕，并保证while循环一定会终止（当查找到i=0时循环条件一定不成立），elem[0]
起到了岗哨作用。因此，不必将“i>0”写入循环条件，从而简化循环条件。这是一个小技巧的应用，但有
关测试表明，这一改进十分有效，当n较大时，进行一次查找所花费的平均时间减少一半。显然，也可以
反过来，将备用区的单元T.elem[n+1]作为岗哨（但此时的循环控制变量i应递增变化）。
下面分析查找运算的时间性能。对于查找运算，其基本操作是“数据元素的键值与给定值的比较”，
所以通常用“数据元素的键值与给定值的比较次数”作为衡量查找算法好坏的依据，称上述比较次数为查
找长度。但是，查找长度与键值在顺序表中位置有关，且差别很大。
例如，若键值在顺序表的第n个位置上，则查找长度为1，而如果键值在顺序表的第1个位置上，查找
长度为n。鉴于这种情况，可以将“查找成功时的平均查找长度”（记为ASL）作为评价查找算法时间性能
的度量。
（3）ASL定义
ASL定义：为找到数据元素在查找表中的位置，与给定值进行比较的键值个数的期望值。当查找表有n
个数据元素时，有


=== 第 158 页 ===
《数据结构导论》学习规划卡
第154页其中，Pi为查找第i个元素（即给定值key与顺序表中第i个元素的键值相等）的概率，且
 ，Ci表示
在找到第i个元素时，与给定值已进行比较的键值个数。假设顺序表为（b1，b2，b3)，查找b1，b2，b3的概
率分别为0.2，0.2，0.6，则顺序查找法的平均查找长度为0.2×3+0.2×2+0.6×1=1.6，即平均需要1.6次键值与
给定值的比较才能找到待查元素。由于多种因素的影响，Pi的值是难以确定的，故通常假设Pi概率相等，
即对所有i，有
，并在此假设下确定查找算法的平均查找长度。按此方式得到顺序查找算法的平均查
找长度为
知识点2有序表上的查找【单选、应用】★★
如果顺序表中数据元素是按照键值大小的顺序排列的，则称为有序表。例如，表6-1中数据元素是按照
“工号”键值从小到大排序的，则此顺序表是有序表。在这种存储表示下，查找运算可以用效率更高的二
分查找法实现。
（1）二分查找的概念
二分查找（BinarySearch）的查找过程为每次用给定值与处在表的中间位置的数据元素的键值进行比较，
确定给定值的所在区间，然后逐步缩小查找区间。重复以上过程直至找到或确认找不到该数据元素为止。
在现实生活中，娱乐节目中的“看商品猜价格”环节就可以很好地应用二分查找的思想猜价格，每次都缩
小价格区间以便猜到正确价格。
用给定值key与处在中间位置的数据元素T.elem[mid]的键值T.elem[mid].key进行比较，可根据三种比
较结果区分三种情况：
①key=T.elem[mid].key，查找成功，T.elem[mid]即为待查元素；
②key<T.elem[mid].key，说明若待查元素若在表中，则一定排在T.elem[mid]之前；
③key>T.elem[mid].key，说明若待查元素若在表中，则一定排在T.elem[mid]之后。
（2）二分查找算法
这里，假定有序表是按键值从小到大有序。二分查找算法如下：

=== 第 159 页 ===
第六章查找
第155页
【例6-1】现有一个含9个数据元素的有序表（关键字即为数据元素的值）：
(10，13，17，20，30，55，68，89，95)
下面给出用二分查找算法查找key=17的过程。
首先，置查找区间初值，置low为1，high为9，即[1，9]是待查区间。
因low<high，取区间中间位置mid=(1+9)/2=5，将mid位置上元素的键值30与key=17比较。因17<30，
说明若待查元素存在，必在区间[low，mid-1]中，即可以将查找区间缩小为[1，4]。此时令high为mid-1，
则新的mid=(1+4)/2=2。
比较17>13，表明若待查元素存在，必在区间[mid+1，high]中，表明区间应修改为[3，4]，则新的
mid=(3+4)/2=3。
比较结果表明T.elem[mid]正是待查元素，查找成功。返回结果为mid=3。
二分查找算法每进行一次键值与给定值的比较，查找区间的长度至少减小为原来二分之一，“二分查
找”由此得名。由此易推算出二分查找的查找长度不超过
 。
二分查找的平均查找长度为

=== 第 160 页 ===
《数据结构导论》学习规划卡
第156页
当n较大时可得
由此可见，二分查找的时间性能比顺序查找好。而相比顺序查找而言，二分查找要求表元素是排好序
的。当采用的存储结构不是顺序表，或者顺序表中元素未按键值的次序（递增或递减）排列时，则不能进
行二分查找。
知识点3索引顺序表上的查找
索引顺序表是结合了顺序查找和二分查找的优点构造的一种带索引的存储结构，如图6-2所示。
由图6-2可知一个索引顺序表由两部分组成：一个索引表和一个顺序表。其中的顺序表在组织形式上与
普通的顺序表完全相同，而索引表本身在组织形式上也是一个顺序表。索引表通过索引将顺序表分割为若
干块，而顺序表呈现出“按块有序”的性质。
所谓“按块有序”是指顺序表中的数据元素被划分成一些子表（块），并且对其中任意两个相邻子表
来说，排在后面的子表中的任一数据元素的键值大于排在前面的子表中的所有数据元素的键值。图6-2中的
顺序表被分成三块：（23，10，15，7，8，21）、（32，43，45，35，25，49）和（61，59，75，58，87，
54），这三块的数据元素是按块有序的，但每一块内元素是无序的。
例如，第一块中的最大键值为23，第二块中的最小键值为25，而23<25，因此第一块中的任一键值小
于第二块中的所有键值。对于顺序表中的每一块，索引表中有相应的一个索引项。每个索引项有两个域：
块内最大键值和块起始位置。图6-2中的顺序表分成三块，索引表就相应地有三个索引项。每一项给出对应
块的最大键值和起始位置。如第2项指出了第2块的最大键值是49和块中第1个数据元素在顺序表中的位
置7。按上述方式组织起来的存储结构称为索引顺序表。
若静态查找表用索引顺序表表示，则查找操作可用分块查找来实现，也称为索引顺序查找。根据上面
对索引顺序表的描述，在索引顺序表上的查找即分块查找分两步进行：
（1）先确定待查数据元素所在的块；

=== 第 161 页 ===
第六章查找
第157页（2）然后在块内顺序查找。
以图6-2所示的索引顺序表为例。假如给定待查key=43，应先将key与索引表中的各个块内最大键值
比较，因为23<43<49，则键值为43的数据元素若存在，则只能在第二块；然后在第二块中进行查找，由于
索引项中指向第二个块中第一个数据元素是顺序表中第7个元素，则自第7个元素起进行顺序查找，直至
找到T.elem[8].key=key为止。在查找过程中第二阶段只能采用顺序查找法，而第一阶段既可采用顺序查找
法也可采取二分查找法（索引表中的索引项按“块内最大键值”域的值有序）。
分块查找的平均查找长度等于两阶段各自的查找长度之和。若每块含S个元素，且第一阶段采用顺序
查找，则在等概率假定下，分块查找的平均查找长度为
其中，n为顺序表中的数据元素数目。当s取
时，ASLbs达到最小值
+1。
下面对三种方法进行性能比较分析，假如现有1000000个数据元素，且其数据元素是按照键值从小到
大次序排列，在理想情况下，构造一个索引顺序表，该表分为1000块，每块1000个数据元素，分别运用
顺序查找、二分查找和索引顺序查找时的平均查找长度为
注意，这里面的数据元素的排序和索引顺序表的分块是要额外花时间的，其中数据元素的排序是下一
章讨论的问题。从上面对比可见分块查找的时间性能高于顺序查找而低于二分查找。但分块查找不要求存
储结构中数据元素按键值有序，因此，在某些情况下索引顺序表是静态查找表的一种可取的实现方法。
总之，静态查找表的上述三种不同实现各有优缺点。其中，顺序查找效率最低但限制最少。二分查找
效率最高，但限制最强。而分块查找则介于上述二者之间。在实际应用中应根据需要加以选择。
【考点练习】
【真题·单选】设有序表中的元素为(13，18，24，35，47，50，62)，则在其中利用二分法查找值为24的元
素需要经过比较的次数是（）。
A.1 B.2
C.3 D.4
【答案】C

=== 第 162 页 ===
《数据结构导论》学习规划卡
第158页【解析】二分法，取中间35进行比对，算一次，小于，继续取左边中间18比对，算一次，大于，继续，
发现只有一个元素24进行比对总共三次。
【真题·填空】静态查找表最简单的实现方法是以______作为存储结构。
【答案】顺序表
第三节二叉排序树
►知识体系
知识点1二叉排序树的概念
静态查找表一旦生成之后，所含数据元素（在检索阶段内）是固定不变的。本节将介绍一种实现动态
查找的树表——二叉排序树，这种树表的结构本身是在查找过程中动态生成的，即对于给定key，若表中存
在与key相等的元素，则查找成功，不然，插入关键字等于key的元素。
一棵二叉排序树（又称二叉查找树）或者是一棵空二叉树，或者是具有下列性质的二叉树：
（1）若它的左子树不空，则左子树上所有结点的键值均小于它的根结点键值；
（2）若它的右子树不空，则右子树上所有结点的键值均大于它的根结点键值；
（3）根的左、右子树也分别为二叉排序树。
例如，图6-3所示为一棵二叉排序树。

=== 第 163 页 ===
第六章查找
第159页
由上述定义和二叉排序树的示例可知，二叉排序树是一种特殊的、增加了限制条件的二叉树，它的存
储结构及其类型定义与二叉树相同。二叉排序树的特殊性表现在结点键值之间的大小关系上，如图6-3所示，
任一结点的键值大于其左孩子（及其子孙）的键值且小于其右孩子（及其子孙）的键值。这样，父子之间
的关系在一定程序上就表示了键值的次序关系。在这种结构下，中序遍历一棵二叉排序树可得到一个键值
的升序序列。例如，图6-3中二叉排序树的中序序列是7，18，20，30，35，38，50，70，76，这是键值的
升序序列。
这就给查找运算的实现提供了便利条件：在表示一棵二叉排序树的二叉链表上，如果一个动态查找表
中的数据元素的键值之间存在某种次序关系，则可以将这些元素组织成一棵二叉排序树，并在二叉排序树
的存储结构上实现动态查找表的基本运算。下面以二叉链表作为二叉排序树的存储结构（其类型定义与第
四章中的二叉链表类型定义相似），讨论动态查找表的查找和插入等运算在这种存储结构上的实现。
二叉排序树的二叉链表的类型定义如下：
知识点2二叉排序树上的查找【单选】
由于二叉排序树的特点，要找键值比某结点键值小（大）的结点，只需通过此结点的左指针（右指针）
到它的左（右）子树中去找。所以查找操作的递归实现较为简单。算法描述如下：

=== 第 164 页 ===
《数据结构导论》学习规划卡
第160页
应用上述算法，在图6-3所示的二叉排序树上分别查找给定值76，22时递归调用的轨迹及返回结果如
图6-4所示。
如图6-4a所示，在图6-3所示的二叉排序树中查找键值等于76的数据元素（树中结点内的值都为数据
元素的键值）。首先以key=76与根结点38比较，因为76>38，则查找以38为根的右子树，右子树不为空
且76>50，则继续查找以50为根的右子树，此时以50为根的右子树的根的键值与key=76相等即查找成功，
返回76结点的指针值。在图6-4b中，查找键值等于22的数据元素。与图6-4a类似的查找过程，当查找到
以结点20为根的右子树时，由于其右子树为空二叉树，则说明查找不成功，返回NULL。
由上面的查找过程可知：在二叉排序树上进行查找，若查找成功，则是从根结点出发走了一条从根结
点到待查结点的路径；若查找不成功，则是从根结点出发走了一条从根到某个叶子的路径。因此与二分查
找类似，关键字比较的次数不超过二叉树的深度。对于同一组结点，由于建立二叉排序树时插入结点的先
后次序不同，所构成的二叉排序树的形态与深度也不同，含有n个结点的二叉排序树不是唯一的。也就是
说，二叉排序树上的查找长度不仅与结点数n有关，也与二叉排序树的生成过程有关。

=== 第 165 页 ===
第六章查找
第161页知识点3二叉排序树的插入【应用】★
由于二叉排序树这种动态树表是在查找过程中，不断地往树中插入不存在的键值而形成的，所以插入
算法必须包含查找过程，并且是在查找不成功时进行插入新结点的操作。
在二叉排序树上进行插入的原则是：必须要保证插入一个新结点后，仍为一棵二叉排序树。这个结点
是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子。
例如，在图6-3所示的二叉排序树中，查找key=22不成功时，到达结点20的右子树，该位置恰好是新
结点22的插入位置，如图6-3、图6-4b和图6-5所示。
基于以上分析，可以将算法SearchBST略加修改，得到插入算描述如下：


=== 第 166 页 ===
《数据结构导论》学习规划卡
第162页
根据以上插入算法，从空树开始不断地进行插入新结点操作可以生成一棵二叉排序树。例如，查找键
值序列为{50，48，24，55，53，50，90}，则生成的二叉排序树如图6-6所示。
这里，应该注意的是，每次插入的新结点都是二叉排序树上新的叶子结点，即在进行插入操作时，不
必移动其他结点，仅需改动某个结点的指针，由空变为非空就行。这也说明，输入键值序列的键值排列顺
序不同，建造的二叉排序树的结构也会不同。

=== 第 167 页 ===
第六章查找
第163页知识点4二叉排序树的查找分析【单选】
二叉排序树上的平均查找长度是介于O(n)和O(log2n)之间的，其查找效率与树的形态有关。图6-7a和
图6-7b的结点的值都相同，但图6-7a的键值输入序列为{30，22，42，7，25}，图6-7b的键值输入序列为{7，
22，25，30，42}，结果形成两个形状不同的二叉排序树。假设5个元素的查找概率相等均为1/5，
则图6-7a的平均查找长度为ASL(a)=(1+2+2+3+3)/5=11/5
图6-7b的平均查找长度为ASL(b)=(1+2+3+4+5)/5=15/5
图6-7a的平均查找长度是O(log2n)，图6-7b中的二叉排序树退化为一条单支，查找算法退化为顺序查
找，平均查找长度上升为(n+1)/2，即平均查找长度是O(n)。故要提高二叉排序树的查找效率，避免出现图
6-7b的情况，需要在二叉排序树的动态变化过程中随时调整其形态，使之保持“平衡”，可以证明，二叉
排序树的平均查找长度ASL≤1+log2n。
【考点练习】
【真题·单选】当查找表中有n个数据元素时，假设Pi(i=1,2,…,n)为查找第i个元素的概率，在Pi等概率的
条件下，顺序查找算法的平均查找长度为（）。
A.n/2 B.(n+1)/2
C.n D.n+1
【答案】B
【解析】顺序查找，平均查找长度上升为(n+1)/2，即平均查找长度是O(n)。
【真题·应用】给定表（19，14，22，01，66，21，83，27，56，13，10），试按元素在表中的次序将它们

=== 第 168 页 ===
《数据结构导论》学习规划卡
第164页依次插入一棵初始时为空的二叉排序树，画出插入完成后的二叉排序树。
【答案】
第四节散列表
►知识体系
数据元素的键值和存储位置之间建立的对应关系H称为散列函数，用键值通过散列函数获取存储位置
的这种存储方式构造的存储结构称为散列表（HashTable），这一映射过程称为散列。如果选定了某个散列
函数H及相应的散列表L，则对每个数据元素X，函数值H（X.key）就是X在散列表L中的存储位置，这
个存储位置也称为散列地址。
理想的情况是，应用的散列函数使每个键值与散列地址是一一对应的，但在实际应用中，这种情况很
少出现。设有散列函数H和键值k1、k2，若k1≠k2，但是H(k1)=H(k2)，则称这种现象为冲突，且称k1、k2
是相对于H的同义词。因为，散列函数是从键值集合到地址集合的映像，所以在一般情况下，冲突只能尽
可能减少而不能完全避免。因此，采用散列技术时需要考虑两个问题：

=== 第 169 页 ===
第六章查找
第165页第一，如何构造（选择）“均匀的”散列函数？
第二，用什么方法有效地解决冲突？
知识点1常用散列法【单选】★
构造散列函数的方法很多，若对于键值集合中的任一个键值，经散列函数映射到地址集合中任何一个
地址的概率是相等的，则称此种散列函数是均匀的。这里介绍几种常用的散列函数的构造方法，按这些方
法构造出来的散列函数计算简单而且比较均匀。以下假定散列地址是自然数，另外，假定键值也都是自然数。
（1）数字分析法
数字分析法又称数字选择法，其方法是收集所有可能出现的键值，排列在一起，对键值的每一位进行
分析，选择分布较均匀的若干位组成散列地址。所取的位数取决于散列表的表长，见表长为100，则取2位
即可。
假定已知可能出现的所有键值如下：
712319721
712618609
712749634
712641816
712816678
712143795
712242763
712915809
对所有键值分析不难看出，左起前三位都是“712”，第5位只能取1、4，第7位只能取6、7、8，
故这5位都不可取。剩下的第4、6、8、9位都是分布较均匀的，可考虑将它们或它们中的几位组织起来作
为散列地址。
（2）除留余数法
除留余数法是一种简单有效且最常用的构造方法，其方法是选择一个不大于散列表长n的正整数p，以
键值除以p所得的余数作为散列地址，即
mod是取余数运算，在C语言中，这一运算符是“%”。值得注意的是这一方法的关键在于p的选取。
若p选的不合适，容易发生冲突。如选p为偶数，则所得的散列函数总是将奇数键值映射成奇数地址，偶
数键值映射为偶数地址，因而增加了冲突的机会。通常选p为小于散列表长度n的素数。
（3）平方取中法
平方取中法以键值平方的中间几位作为散列地址。这一方法计算简单，是一种较常用的构造散列函数
的方法，通常在选定散列函数时不一定能知道键值的分布情况。取其中哪几位也不一定合适，而一个数平

=== 第 170 页 ===
《数据结构导论》学习规划卡
第166页方的中间几位与这个数的每一位都有关，所得散列地址比较均匀。
（4）基数转换法
将键值看成另一种进制的数再转换成原来进制的数，然后选其中几位作为散列地址。例如，对于十进
制键值443730，先把它看成是十三进制的数并转换为十进制数：
44373013=4×135+4×134+3×133+7×132+3×131+0×130
=160722910
然后，根据散列表的长度从中选取几位作为散列地址。
知识点2散列表的实现【单选、应用】★★★
假设散列表的地址集为0～(n-1)，冲突是指由键值得到的散列地址上已存有元素，则解决冲突就是为该
键值的元素找到一个空闲单元的散列地址。在解决冲突的过程中可能得到一个地址序列Hi，i=1，2，3，…，
k(0≤Hi≤n-1)，在解决冲突时，若得到的某个散列地址Hk仍然发生冲突，则再求下一个地址Hk+1，若仍冲
突再求得Hk+2。以此类推直到不发生冲突为止，这时得到的散列地址即为该元素在表中的地址。
通常用来解决冲突的方法有以下几种：
（1）线性探测法
对任何键值key，设H(key)=d，设散列表的容量为m，则线性探测法生成的后继散列地址序列为
d+1，d+2，…，m-1，0，1，…，d-1
例如，如图6-8所示长度为13的散列表，其散列函数为H(key)=keymod13，在表中已填入键值分别为
16，30，54的元素。现要插入其键值为29的元素，散列函数求出其散列地址为3，在地址3上面已有元素
16，发生冲突。应用线性探测法，得到下一个地址为d+1=4，仍冲突，则再求下一个地址d+2=5，这个位置
上没有元素，将元素填入散列表中序号为5的单元。
从上面的过程可以看出，用线性探测法生成后继散列地址计算简单，但由于探测的是一个连续的地址
序列，这也引出新的问题。如图6-8中的30和29本来不是同义词，但是发生了冲突，这种非同义词之间对
同一个散列地址的争夺现象称为“堆积”。为了减少堆积的机会，应设法使后继散列地址尽量均匀地分散
在整个散列表中。
（2）二次探测法
二次探测法的基本思想：生成的后继散列地址不是连续的，而是跳跃式的，以便为后续数据元素留下
空间从而减少堆积。按照二次探测法，键值key的散列地址序列为

=== 第 171 页 ===
第六章查找
第167页
其中，m为散列表的表长，i=12，-12，22，-22，…，±k2(k≤m/2)。插入元素29的过程如图6-9所示，当发生
冲突时，应用二次探测法，得到下一个地址d1=(3+12)mod13=4仍冲突，则再求下一个地址d2=(3-12)mod13=2
仍冲突，直到散列地址为d3=(3+22)mod13=7时其位置上没有元素，即元素填入散列表中序号为7的位置。
二次探测法的缺点是不易探测到整个散列表的所有空间，也就是说，上述后继散列地址可能难以包括
散列表的所有存储位置。
（3）链地址法
链地址法是对每一个同义词都建一个单链表来解决冲突，其组织方式如下：
设选定的散列函数为H，H的值域（即散列地址的范围）为0～(n-1)。设置一个“指针向量”PointerHP[n]，
其中的每个指针HP[i]指向一个单链表，该单链表用于存储所有散列地址为i的数据元素。每一个这样的单
链表称为一个同义词子表。例如，若选定的散列函数为H(key)=keymod13，已存入键值为26，41，25，05，
07，15，12，49，51，31，62的散列表，如图6-10所示。
（4）多重散列法

=== 第 172 页 ===
《数据结构导论》学习规划卡
第168页此法要求设立多个散列函数Hi，i=1，…，k。当给定值key与散列表中的某个键值是相对于某个散列
函数Hi的同义词而发生冲突时，继续计算这个给定值key在下一个散列函数Hi+1下的散列地址，直到不再
产生冲突为止。这种方法的优点是不易产生“堆积”，缺点是计算量较大。
（5）公共溢出区法
按这种方法，散列表由两个一维数组组成。一个称为基本表，它实际上就是上面所说的散列表，另一
个称为溢出表。插入首先在基本表上进行，假如发生冲突，则将同义词存入溢出表。这样，基本表不可能
发生“堆积”。
知识点3散列表的基本操作算法
在上面介绍的冲突解决方法中，常用的是线性探测法、二次探测法和链地址法。解决冲突的方法得到
的散列表主要分为两类，下面分别讨论以线性探测法和链地址法解决冲突的散列表的查找和插入操作。
（1）链地址法散列表
类型定义如下：
这种散列表查找的过程是首先计算给定值key的散列地址i，由它到指针向量中找到指向key的同义词
子表的表头指针。然后，在该同义词子表中顺序查找键值为key的结点。算法描述如下：
散列表上的插入算法应包含查找功能，并在查找不成功时申请一个结点来存储这个元素，实施新结点
的链入操作。为简单起见，调用上述查找算法，当查找不成功时用“前插法”插入新结点，即将新结点插
到同义词子表的表头结点之后、原表首结点（若存在的话）之前。

=== 第 173 页 ===
第六章查找
第169页对查找算法作以下修改：
①找到待查结点时将其删除；
②找不到待查结点，则返回，就得到散列表的删除算法描述如下：
（2）线性探测法散列表
散列表数据元素的类型定义如下：
用线性探测法解决冲突的散列表查找运算的实现算法描述如下：

=== 第 174 页 ===
《数据结构导论》学习规划卡
第170页
【考点练习】
【真题·单选】有关解决冲突的方法中，描述正确的是（）。
A.多重散列法不易产生“堆积”
B.线性探测法生成后继散列地址计算复杂
C.二次探测法生成的后继散列地址是连续的
D.二次探测法容易探测到整个散列表的所有空间
【答案】A
【解析】多重散列法的优点是不易产生“堆积”，缺点是计算量较大。
【真题·填空】要完全避免散列所产生的“堆积”现象，通常采用______解决冲突。
【答案】公共溢出区
【真题·应用】已知键值序列(11，2，13，26，5，18，4，9)，设散列表表长为13，散列函数H(key)=keymod
13，处理冲突的方法为线性探测法，请给出散列表。
【答案】散列表：


=== 第 175 页 ===
第七章排序
第171页第七章排序
►知识体系


=== 第 176 页 ===
《数据结构导论》学习规划卡
第172页►考点透析
知识点 考核要求 考试题型 重点星级
排序的定义 识记 填空
内部排序和外部排序 识记
插入排序的定义 识记
直接插入排序算法 简单应用 应用 ★
冒泡排序 简单应用 单选、应用 ★★
快速排序 识记 单选、填空 ★
直接选择排序 识记
堆排序 识记 单选 ★
有序序列的合并 领会
二路归并排序 领会

=== 第 177 页 ===
第七章排序
第173页第一节概述
►知识体系
知识点1排序的定义【填空】
排序就是将一组对象按照规定的次序重新排列的过程，排序往往是为检索服务的。例如，图书馆中书
的摆放就是按照索引号排序后的结果，这大大减少了人们检索图书的时间。像这样的先排序再检索的例子
在现实生活中无处不在。例如，电话号码簿、字典等等，都是排序的应用。
例如，在表1-1学生档案数据中，该信息表是以学号键值从小到大排序的，如果按照年龄从小到大排序，
就可得到表7-1所示的结果，表中的每一行代表一条记录。
对表1-1学生档案数据按照入学成绩从高到低进行重新排序，排序后的结果见表7-2所示，所有记录满
足按入学成绩从高到低排列。


=== 第 178 页 ===
《数据结构导论》学习规划卡
第174页在表1-1和表7-2所示的数据中，请读者注意一种现象，学号为1002和学号为1004的两位学生入学成
绩相同，在排序后相对位置没有发生变化。相同键值的两个记录在排序前后相对位置的变化情况是排序算
法研究中经常关注的一个问题，这个问题称为排序算法的稳定性。
n个记录的序列为{R1，R2，…，Rn}，其相应的键值序列为{k1，k2，…，kn)，假设ki=kj，若在排序前
的序列中Ri在Rj之前，即i<j，经过排序后，Ri仍在Rj之前，则称所用的排序方法是稳定的；反之，则称
所用的排序方法是不稳定的。
注意：稳定性是排序方法本身的特性，与数据无关，换句话说，一种排序方法如果是稳定的，则对所
有的数据序列都是稳定的，反过来，如果在一组数据上出现不稳定的现象，则该方法是不稳定的。
知识点2内部排序和外部排序
排序可分为两大类：
（1）内部排序：待排序的记录全部存放在计算机内存中进行的排序过程；
（2）外部排序：待排序的记录数量很大，内存不能存储全部记录，需要对外存进行访问的排序过程。
内部排序的方法很多，本书主要介绍插入排序、交换排序、选择排序和归并排序等四种。评价一个排
序算法的优劣，通常也是用时间复杂度和空间复杂度这两个指标，这里主要讨论时间复杂度。在排序过程
中主要有比较两个键值大小和将记录从一个位置移动到另一个位置这两种基本操作。因此，从键值的比较
次数和记录的移动次数两个方面来分析时间复杂度。
由于排序算法的多样性，很难确定一种公认的最好方法。例如，当待排序序列已基本有序时，插入排
序和交换排序比较有效；当待排记录数量较大时，选择排序比较有效。各种方法都有自己适合的不同情况，
在实际应用中应该选择适当的方法。
在没有特别说明时，本章讨论各种排序方法均要求排成按键值递增的序列。待排序的数据存储结构，
用类C语言描述如下：
其中，key是数据记录排序时的键值，实际应用中其类型可以为整型、实型或者字符串等。这里为了讨论方
便，设key为整型。n为序列中待排序记录的总数。List型变量的第0个记录可以闲置或用来暂存某个记录
值，可以用作：“岗哨”（例7-1）。

=== 第 179 页 ===
第七章排序
第175页【考点练习】
【真题·填空】相同键值的两个记录在排序前后相对位置的变化情况是排序算法研究中经常关注的一个问题，
这个问题称为排序算法的______。
【答案】稳定性
第二节插入排序
►知识体系
知识点1插入排序的定义
常用的插入排序方法有直接插入排序、折半插入排序、表插入排序和希尔排序。本节只介绍直接插入
排序。
直接插入排序是一种简单的排序方法，它的基本思想是依次将每个记录插入到一个已排好序的有序表
中去，从而得到一个新的、记录数增加1的有序表。直接插入排序类似图书馆中整理图书的过程。
待排序记录初始键值序列为
在这个键值序列中有两个相同的键值45，为了便于区分它们和说明算法的稳定性，在第二个45下面加
了下划线。
假设在排序过程中，前4个记录已按键值递增顺序重新排列，构成了一个有序序列为
现在要将序列（7-1）中第5个键值88插入序列（7-2）中，首先在序列（7-2）中查找以确定88所应
插入的位置，然后进行插入操作。假设从90起向左顺序查找，由于66<88<90，则88的插入位置应该在66
和90之间，即可以得到新的含有5个记录的有序序列为

=== 第 180 页 ===
《数据结构导论》学习规划卡
第176页
一般情况下，第i(i≥1)个记录进行插入操作时，R1，R2，…，Ri-1是排好序的有序表，取出第i个元素
Ri，在R1，R2，…，Ri-1中为Ri找到一个合适的位置并将它插到该位置上。易知，如果序列只有一个记录，
显然是已经排好序的，故可直接从i=2开始。
知识点2直接插入排序算法【应用】★
直接插入排序算法描述如下：
记录R[0]有两个作用：
其一是进入查找循环之前，它保存了R[i]的值，使得不致于因记录的后移而丢失R[i]中的内容；
其二是起岗哨作用，在while循环中“监视”数组下标变量j是否越界，一旦越界（即j<1），R[0]自
动控制while循环的结束，从而避免了在while循环中每一次都要检测j是否越界。这一技巧的应用，使得
测试循环条件的时间大约减少一半。
【例7-1】应用直接插入排序方法，对序列（7-1）所示的一组键值进行排序，过程如图7-1所示。
【分析】直接插入排序过程如下：

=== 第 181 页 ===
第七章排序
第177页
直接插入排序的算法简单，易于理解，容易实现，时间复杂度为O(n²)，若待排序记录的数量很大时，
一般不选用直接插入排序。从空间来看，它只需要一个记录的辅助空间，即空间复杂度为O(1)。直接插入
排序方法是稳定的。
第三节交换排序
►知识体系
交换排序的基本思想：比较两个记录键值的大小，如果这两个记录键值的大小出现逆序，则交换这两
个记录，这样将键值较小的记录向序列前部移动，键值较大的记录向序列后部移动。

=== 第 182 页 ===
《数据结构导论》学习规划卡
第178页知识点1冒泡排序【单选、应用】★★
冒泡排序法是一种交换排序方法，其过程是首先将第一个记录的键值和第二个记录的键值进行比较，
若为逆序（即R[1].key>R[2].key），则将这两个记录交换，然后继续比较第二个和第三个记录的键值。依次
类推，直到完成第n-1个记录和第n个记录的键值比较交换为止。上述过程称为第一趟起泡，其结果使键值
最大的记录移到了第n个位置上。然后再进行第二趟起泡排序，即对前n-1个记录进行同样操作，其结果是
次大键值的记录安置在第n-1个位置上。重复以上过程，当在一趟起泡过程中没有进行记录交换的操作时，
整个排序过程终止。
【例7-2】设待排序的键值为
4538669088102545
冒泡排序的过程如图7-2所示。
【分析】第一行为初始键值序列，第二行起依次为各趟起泡的结果，图中非加粗的键值是当前待排序
的无序序列。
该方法的排序过程与气泡从水中往上冒的情况类似，所以称为冒泡排序。从图7-2中可以看出，在起泡
过程中，键值较小的记录好比气泡一样向上漂浮，键值较大的记录则向下沉，因为每趟都有一个最大键值
的记录沉到水底，所以整个排序过程至多需要进行n-1趟起泡。但是，若在某一趟起泡过程中未发现气泡位
置的交换，则说明序列中所有气泡均满足轻者在上，重者在下的原则，即记录已经排好序，此时可以终止
冒泡排序过程。在图7-2的示例中，在第六趟起泡过程中就没有交换气泡位置，此时序列已经有序。在算法
实现时，定义一个整型变量endsort，在每一次排序之前，先将它置为0，若在一趟起泡中交换了记录，则
将它置为1。当一次循环结束时，我们再检查endsort，若endsort的值为0便终止算法。
冒泡排序的算法描述如下：

=== 第 183 页 ===
第七章排序
第179页
该算法的时间复杂度为O(n²)，冒泡排序是稳定的排序方法。
知识点2快速排序【单选、填空】★
快速排序是交换排序的一种，实质上是对冒泡排序的一种改进。它的基本思想：在n个记录中取某一
个记录的键值为标准，通常取第一个记录键值为基准，通过一趟排序将待排的记录分为小于或等于这个键
值和大于这个键值的两个独立的部分，这时一部分的记录键值均比另一部分记录的键值小，然后，对这两
部分记录继续分别进行快速排序，以达到整个序列有序。
一趟快速排序的具体做法：附设两个指针i和j，它们的初值分别为1和n，且把R[1]送入工作单元x
中保存。首先j从n起逐渐减小找到第一个满足R[j].key<x.key的记录，这时将R[j]移至R[i]的位置；然后
令i自i+1起逐渐增大找到第一个满足R[i].key>x.key的记录，这时将R[i]移至R[j]位置；接着j自j-1起重
复上述过程，直至i=j，此时i便是记录x所应在的位置，至此，一趟快速排序完成。此时序列R被分为：
R[1]，…，R[i-1]和R[i+1]，…，R[n]两部分。具体过程如图7-3所示。
注意：算法实现中，键值为45的记录在每次“交换”中并不移动它的存储位置。仅在第四次交换之后，
即找到它的“正确”位置之后，才移入该位置。
下面给出一趟快速排序的算法：

=== 第 184 页 ===
《数据结构导论》学习规划卡
第180页
完整的快速排序可写成如下递归算法：
【例7-3】用快速排序方法对4538669088102545进行排序。
【分析】


=== 第 185 页 ===
第七章排序
第181页当对整个记录序列R进行快速排序时，只需调用QuickSort(R，1，n)即可。图7-3给出了第一次划分的
结果。图7-4给出了上述键值序列利用快速排序算法进行排序的完整过程，图中方括号表示无序区。
用一棵二叉树来表示上例QuickSort算法的执行过程，如图7-5所示（不计划分过程，为了方便省略R）。
在图7-5中所示的二叉树中，非叶子结点表示要调用QuickPartition函数(low<high)，而叶子结点则表示
不调用QuickPartition函数(low≥high)。例如，在QuickSort(5，4)递归时，由于5>4，不执行QuickPartition
函数，即不再需要继续划分。当将快速排序算法的递归调用过程用上述二叉树表示出来后，可以看出算法
的执行过程实质是对应二叉树的先序遍历过程，递归调用的顺序是：
→QuickSort(1，8)→QuickSort(1，3)→QuickSort(1，1)→QuickSort(3，3)→QuickSort(5，8)→QuickSort(5，
6)→QuickSort(5，4)→QuickSort(6，6)→QuickSort(8，8)
则快速排序算法的执行过程如图7-6所示。

=== 第 186 页 ===
《数据结构导论》学习规划卡
第182页
图7-6所示的初始关键字共经过4次处理完成排序，也就是图7-6中编号分别为（1）、（2）、（5）、
（6）的那些行。叶结点由于不涉及递归调用，QuickPartition可以省去。这样，我们用先序遍历二叉树的方
法就解释了快速排序算法的总体执行过程（不计划分过程）。
快速排序是不稳定的，现举例来说明。
【例7-4】用快速排序方法对关键字序列90102538668810进行排序。
从图7-7中的初始关键字序列和最终排序结果可以看出，关键字10和10在排序前后相对顺序发生了改
变，即找到了一组关键字：90102538668810，在这组关键字的排序过程中，快速排序方法是
不稳定的，这说明快速排序方法本身是不稳定的。
就平均时间性能而言，快速排序方法最佳，其时间复杂度为O(nlog2n)。但在最坏情况下，即对几乎已
是排好序的输入序列，该算法的效率较低，近似于O(n²)。另外，对于较小的n值该算法效果不明显；反之，
对较大的n值效果较好。

=== 第 187 页 ===
第七章排序
第183页【考点练习】
【真题·单选】冒泡排序属于（）。
A.插入排序 B.归并排序
C.选择排序 D.交换排序
【答案】D
【解析】冒泡排序法是一种交换排序方法。交换排序是通过不断交换元素的位置来达到排序的目的，而冒
泡排序就是其中的一种方法。
【真题·填空】快速排序实质上是对______排序的一种改进。
【答案】冒泡
第四节选择排序
►知识体系
选择排序的基本思想：每一次在n-i+1(i=1，2，…，n-1)个记录中选取键值最小的记录作为有序序列的
第i个记录。本节介绍直接选择排序和堆排序两种选择排序方法。
知识点1直接选择排序
直接选择排序算法的基本思想：在第i次选择操作中，通过n-i次键值间比较，从n-i+1个记录中选出
键值最小的记录，并和第i(1≤i≤n-1)个记录交换。算法描述如下：


=== 第 188 页 ===
《数据结构导论》学习规划卡
第184页
上述算法中，函数swap(R[min]，R[i])功能是将记录R[min]和R[i]交换。从算法中可以看出，固定一个
i，当j每一次循环结束后，只要将第i个记录和当前最小键值的记录进行交换，其他记录保持不动。
【例7-5】对初始关键字序列45，38，66，90，88，10，25，45的记录，采用直接选择排序，给出排
序过程和结果。
【分析】直接选择排序过程和结果如图7-8所示。
算法的主要部分包含两层嵌套的for循环，其时间复杂度为O(n²)。直接选择排序算法简单，容易实现，
但不适宜于n较大的情况。
直接选择排序是不稳定的，现举例来说明。
【例7-6】对初始关键字序列45，38，66，90，88，25，45，10的记录进行直接选择排序，给出排序
过程和结果。
【分析】排序过程和结果如图7-9所示。

=== 第 189 页 ===
第七章排序
第185页
从例7-6中的初始关键字和最终排序结果可以看出，关键字45和45在排序前后相对顺序发生了改变，
说明在这组关键字下直接选择排序方法是不稳定的。
知识点2堆排序【单选】★
（1）堆排序的定义
对直接选择排序分析可知，在n个键值中选出最小值，至少进行n-1次比较。然而继续在剩余的n-1个
键值中选出次小值是否一定要进行n-2次比较呢？如果能利用前n-1次比较所得信息，是否可减少以后各次
选择中的比较次数呢？基于以上分析，本节讨论堆排序。
堆定义如下：若有一个关键字序列{k1，k2，…，kn}满足
其中，i=1，2，…，
，则称这个n个键值的序列{k1，k2，…，kn}为最小堆（或最大堆）。
由上述定义可知，最小堆可以看成是一棵以k1为根的完全二叉树，在这棵二叉树中，任一结点的值都
不大于它的两个孩子的值（若存在孩子的话）。因此，如果{k1，k2，…，kn}这个序列是最小堆，则k1（即
堆顶元素或称为二叉树的根）是堆中最小的元素，并且这种二叉树的任一子树本身也是一个堆。
例如，键值序列{13，40，27，88，55，34，65，92}就是一个最小堆，与它对应的完全二叉树如图7-10a
所示。
同理，由上述定义可知，最大堆可以看成是一棵以k1为根的完全二叉树，在这棵二叉树中，任一结点
的值都不小于它的两个孩子的值（若存在孩子的话）。因此，如果{k1，k2，…，kn}这个序列是最大堆，则
k1（即堆顶元素或称为二叉树的根）是堆中最大的元素，并且这种二叉树的任一子树本身也是一个堆。

=== 第 190 页 ===
《数据结构导论》学习规划卡
第186页例如，键值序列{92，65，88，40，55，34，13，27}就是一个最大堆，与它对应的完全二叉树如图7-10b
所示。
最小堆：{13，40，27，88，55，34，65，92}
最大堆：{92，65，88，40，55，34，13，27}
下标：12345678
不失一般性，以下只介绍基于最小堆的堆排序。读者可以将其扩展到最大堆的堆排序。
若在输出堆顶的最小键值之后，使得剩余的n-1个键值重新建成一个堆，则可得到n个键值中的次最小
值。如此反复执行，便能得到有序序列，这个过程称之为堆排序。
因此，实现堆排序需要解决两个问题：
①如何由一个初始序列建成一个堆？
②如何在输出堆顶元素之后调整剩余元素成为一个新堆？
下面先讨论第二个问题。例如，图7-11a是个堆，在输出堆顶元素13之后，以堆中最后一个元素92替
代之，如图7-11b所示。此时只有堆顶元素改变，其左、右子树均还为堆，所以只需要自上而下进行调整，
得到一个新堆。做法如下：首先以新的根92和其左、右子树根结点的值比较，选出三者最小者作为根。由
于右子树根结点的值27小于左子树根结点的值34且小于根结点的值92，因此将27和92交换；由于92替
代了27之后破坏了右子树的堆，则需进行和上述相同的调整，调整后的状态如图7-11c所示，此时堆顶为
n-1个元素中的最小值。重复上述过程将堆顶元素27和堆中最后一个元素65交换且调整得到如图7-11d所
示的新堆。

=== 第 191 页 ===
第七章排序
第187页
（2）堆排序的算法
这个自堆顶向下的调整过程称为“筛选”，算法描述如下：


=== 第 192 页 ===
《数据结构导论》学习规划卡
第188页
将一个初始序列建成一个堆就是一个反复“筛选”的过程。其主要过程是：首先将要排序的所有键值
看成一棵完全二叉树的各个结点（这时的完全二叉树并不一定具备堆的特性），根据完全二叉树性质最后
一个非终端节点是第
个元素，即对于i>
的结点ki都没有孩子结点，因此以这样的ki为根的子树已经
是堆，所以“筛选”只需从开始，逐步把以
 为根的子树“筛选”成堆，
就完成了建堆的过程。堆排序算法描述如下：
【例7-6】对于与键值集合{65，88，55，34，92，27，13，40}对应的二叉树，用筛选法建堆的过程如
图7-12所示。其中n=8，n/2=4，所以从k4=34开始执行。

=== 第 193 页 ===
第七章排序
第189页
图7-13给出这个堆进行堆排序的完整过程。
堆排序在待排序记录较少时不适用，但对记录数很多时是很有效的，因为其主要运行时间耗费在建初
始堆和不断“筛选”的过程。对于n个记录进行排序所需的平均时间是O(nlog2n)。在最坏情况下，其时间
复杂度也为
 。相对于快速排序来说，这是堆排序的最大优点。此外，堆排序仅需一个记录大小
的供交换用的辅助存储空间。

=== 第 194 页 ===
《数据结构导论》学习规划卡
第190页堆排序是不稳定的。下面举例来说明它的不稳定性。


=== 第 195 页 ===
第七章排序
第191页【例7-7】对于关键字序列{13，40，55，88，40}，给出堆排序的过程和结果。
{13，40，55，88，40}
下标：12345
初始关键字序列{13，40，55，88，40}对应的完全二叉树如图7-14所示。易验证它是一个初始堆。初
始关键字中有两个相同的关键字40和40。在排序前，40是在40之前。这组关键字的排序过程如图7-15
所示。
最后排序结果为13，40，40，55，88。可以看出两个关键字40，40在排序后次序发生改变。这说明堆
排序是不稳定的。


=== 第 196 页 ===
《数据结构导论》学习规划卡
第192页【考点练习】
【真题·单选】下列序列中，符合堆定义的是（）。
A.(100，80，55，60，50，40，58，35，20)B.(100，80，55，60，50，40，35，58，20)
C.(100，80，55，58，50，40，60，35，20)D.(100，70，55，60，0，40，58，35，20)
【答案】B
【解析】堆定义如下：若有一个关键字序列{k1，k2，…，kn}满足
其中，i=1，2，…，
，则称这个n个键值的序列{k1，k2，…，kn}为最小堆（或最大堆）。
第五节归并排序
►知识体系
归并排序是与插入排序、交换排序、选择排序不同的一类排序方法，其不同之处在于要求待排序列是
由若干个有序子序列组成。归并的含义是将两个或两个以上的有序表合并成一个新的有序表。合并的方法
是比较各子序列的第一个记录的键值，最小的一个就是排序后序列的第一个记录的键值。取出这个记录，
继续比较各子序列现有的第一个记录的键值，便可找出排序后的第二个记录。如此继续下去，最终可以得
到排序结果。因此归并排序的基础是合并。
知识点1有序序列的合并
归并排序中的核心操作是两个有序子序列的合并。假设有两个有序序列ah，…，am和am+1，…，an，它
们相应的键值分别满足，Kh<=…<=Km，Km+1<=…<=Kn，合并成一个有序序列Rh，…，Rn，使合并后的序
列键值满足K'h<=…<=K'm<=K'm+1<=…<=K'n。
有序序列的合并算法描述如下：

=== 第 197 页 ===
第七章排序
第193页
此算法的执行时间为O(n-h+1)。
知识点2二路归并排序
二路归并排序即是将两个有序表合并成一个有序表的排序方法，其基本思想：假设序列中有n个记录，
可看成是n个有序的子序列，每个序列的长度为1。首先将每相邻的两个记录合并，得到
个较大的有序
子序列，每个子序列包含2个记录，再将上述子序列两两合并，得到
 个有序子序列，如此反复，
直至得到一个长度为n的有序序列为止，排序结束。
【例7-8】图7-16是初始关键字序列{25，9，78，6，65，15，58，18，45，20}采用归并排序法进行排
序的示例。
二路归并算法的核心是每一次的归并操作，所以根据前面介绍的算法Merge，写出执行一次归并的算法
MergePass如下：

=== 第 198 页 ===
《数据结构导论》学习规划卡
第194页
对含有n个记录的序列A运用二路归并排序算法进行排序，就是进行若干次二路归并操作，所以应用
MergePass即可写出算法。其中每次归并后有序子序列长度h扩大一倍，且第一次归并时有序子序列长度h
为1。排序过程结束的条件是h≥n。
二路归并排序算法描述如下：
归并排序涉及上述三个算法，这三个算法执行顺序是先调用函数MergeSort，在MergeSort中调用函数
MergePass，在MergePass调用函数Merge。归并排序算法的时间复杂度为O(nlog2n)，由于要用到和待排记
录等数量的数组b来存放结果，所以实现归并排序需要附加一倍的存储开销。二路归并排序是稳定的。
在n较大时，归并排序的时间性能优于堆排序，但它所需的辅助存储量较多。
